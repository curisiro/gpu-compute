!function(n){var i={};function t(e){if(i[e])return i[e].exports;var o=i[e]={i:e,l:!1,exports:{}};return n[e].call(o.exports,o,o.exports,t),o.l=!0,o.exports}t.m=n,t.c=i,t.d=function(n,i,e){t.o(n,i)||Object.defineProperty(n,i,{enumerable:!0,get:e})},t.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},t.t=function(n,i){if(1&i&&(n=t(n)),8&i)return n;if(4&i&&"object"==typeof n&&n&&n.__esModule)return n;var e=Object.create(null);if(t.r(e),Object.defineProperty(e,"default",{enumerable:!0,value:n}),2&i&&"string"!=typeof n)for(var o in n)t.d(e,o,function(i){return n[i]}.bind(null,o));return e},t.n=function(n){var i=n&&n.__esModule?function(){return n.default}:function(){return n};return t.d(i,"a",i),i},t.o=function(n,i){return Object.prototype.hasOwnProperty.call(n,i)},t.p="",t(t.s=10)}([function(n,i,t){"use strict";var e;function o(){if(!e)try{const n=document.createElement("canvas");if(!n)throw new Error("unable to create canvas");const i=n.getContext("webgl2");if(i&&"undefined"!=typeof WebGL2RenderingContext)console.debug("your browser supports WebGL2"),e=i;else{console.debug("your browser doesn't support WebGL2");const i=n.getContext("webgl");if(!i)throw new Error("unable to get context");e=i}}catch(n){throw new Error("unable to get WebGL context from canvas")}return e}Object.defineProperty(i,"__esModule",{value:!0}),i.getMaxRenderBufferSize=i.isWebGL2=i.setWebGLContext=i.getWebGLContext=void 0,i.getWebGLContext=o,i.setWebGLContext=function(n){return e=n||o()},i.isWebGL2=function(){return"undefined"!=typeof WebGL2RenderingContext&&o()instanceof WebGL2RenderingContext};var r=0;i.getMaxRenderBufferSize=function(){if(!r){const n=o();r=n.getParameter(n.MAX_RENDERBUFFER_SIZE)}return r}},function(n,i,t){"use strict";Object.defineProperty(i,"__esModule",{value:!0}),i.ComputeShader=i.passThruFrag=i.passThruVert=void 0;const e=t(0);i.passThruVert="\n#ifdef GL_ES\nprecision mediump float;\nprecision mediump int;\nprecision mediump sampler2D;\n#endif\n\nattribute vec3 a_position;\n\nvoid main() {\n  gl_Position = vec4(a_position, 1.0);\n}",i.passThruFrag="\n#ifdef GL_ES\nprecision mediump float;\nprecision mediump int;\nprecision mediump sampler2D;\n#endif\n\nuniform sampler2D u_tex;\nuniform float u_textureWidth;\n\nvoid main() {\n  gl_FragColor = texture2D(u_tex, gl_FragCoord.xy / u_textureWidth);\n}";i.ComputeShader=class{constructor(n,t,o,r){r=r?e.setWebGLContext(r):e.getWebGLContext(),this.vertShader=this.createVertShader(this.searchAndReplace(o||i.passThruVert,t)),this.fragShader=this.createFragShader(this.searchAndReplace(n,t)),this.program=this.createProgram(this.vertShader,this.fragShader),this.attributeInfo=this.getAttributeInfo(r,this.program),this.uniformInfo=this.getUniformInfo(r,this.program)}delete(){const n=e.getWebGLContext();n.deleteShader(this.vertShader),n.deleteShader(this.fragShader),n.deleteProgram(this.program)}preprocess(n){return(n=(n=(n=n.replace(/\t/g,"    ")).replace(/\r+/gm,"")).replace(/\n{3,}/g,"\n\n")).trim()}createVertShader(n){const i=e.getWebGLContext(),t=i.createShader(i.VERTEX_SHADER);if(!t)throw new Error("unable to create new vertex shader");if(i.shaderSource(t,this.preprocess(n)),i.compileShader(t),!i.getShaderParameter(t,i.COMPILE_STATUS))throw new Error(`could not compile vertex shader: ${i.getShaderInfoLog(t)}\n\n${n.trim()}`);return t}createFragShader(n){const i=e.getWebGLContext(),t=i.createShader(i.FRAGMENT_SHADER);if(!t)throw new Error("unable to create new fragment shader");if(i.shaderSource(t,this.preprocess(n)),i.compileShader(t),!i.getShaderParameter(t,i.COMPILE_STATUS))throw new Error(`could not compile fragment shader: ${i.getShaderInfoLog(t)}\n\n${n.trim()}`);return t}createProgram(n,i){const t=e.getWebGLContext();var o=t.createProgram();if(!o)throw new Error("unable to create program");if(t.attachShader(o,n),t.attachShader(o,i),t.linkProgram(o),!t.getProgramParameter(o,t.LINK_STATUS))throw new Error("error in program linking: "+t.getProgramInfoLog(o));return o}searchAndReplace(n,i){if(i)for(var[t,e]of Object.entries(i))n=n.replace(t,e);return n}getAttributeInfo(n,i){const t={},e=n.getProgramParameter(i,n.ACTIVE_ATTRIBUTES);for(let o=0;o<e;o++){const e=n.getActiveAttrib(i,o);if(null===e)continue;const r=n.getAttribLocation(i,e.name);null!==r&&(t[e.name]={size:e.size,type:e.type,location:r})}return t}getUniformInfo(n,i){const t={},e=n.getProgramParameter(i,n.ACTIVE_UNIFORMS);for(let o=0;o<e;o++){const e=n.getActiveUniform(i,o);if(null===e)continue;const r=n.getUniformLocation(i,e.name);null!==r&&(t[e.name]={size:e.size,type:e.type,location:r})}return t}}},function(n,i,t){"use strict";var e=Object.create?function(n,i,t,e){void 0===e&&(e=t),Object.defineProperty(n,e,{enumerable:!0,get:function(){return i[t]}})}:function(n,i,t,e){void 0===e&&(e=t),n[e]=i[t]},o=Object.create?function(n,i){Object.defineProperty(n,"default",{enumerable:!0,value:i})}:function(n,i){n.default=i},r=function(n){if(n&&n.__esModule)return n;var i={};if(null!=n)for(var t in n)Object.hasOwnProperty.call(n,t)&&e(i,n,t);return o(i,n),i};Object.defineProperty(i,"__esModule",{value:!0}),i.expandDefinitions=i.functionStrings=void 0;const a=r(t(12)),f="\nfloat round(float f) {\n  return floor(f + 0.5);\n}".trim(),T="\nfloat vec2ToInt16(vec2 v) {\n  return clamp(floor(floor(v.r * 255.0) * 256.0) + floor(v.g * 255.0) - 32767.0, -32767.0, 32768.0);\n}".trim(),l="\nvec2 int16ToVec2(float f) {\n  f = clamp(f, -32767.0, 32768.0) + 32767.0; \n  return vec2(floor(f / 256.0), f - floor(f / 256.0) * 256.0) / 255.0; \n}".trim(),s="\nfloat vec2ToUint16(vec2 v) {\n  return clamp(floor(floor(v.r * 255.0) * 256.0) + floor(v.g * 255.0), 0.0, 65535.0);\n}".trim(),u="\nvec2 uint16ToVec2(float f) {\n  f = clamp(f, 0.0, 65535.0); \n  return vec2(floor(f / 256.0), f - floor(f / 256.0) * 256.0) / 255.0; \n}".trim(),d="\nvoid unpackBooleans(float f, inout bool arr[8]) {\n  f = floor(f * 255.0);\n  arr[0] = bool(int(1.0 - max(sign(128.0 - f), 0.0)));  \n  f -= (1.0 - max(sign(128.0 - f), 0.0)) * 128.0;\n  arr[1] = bool(int(1.0 - max(sign(64.0 - f), 0.0)));\n  f -= (1.0 - max(sign(64.0 - f), 0.0)) * 64.0;\n  arr[2] = bool(int(1.0 - max(sign(32.0 - f), 0.0)));\n  f -= (1.0 - max(sign(32.0 - f), 0.0)) * 32.0;\n  arr[3] = bool(int(1.0 - max(sign(16.0 - f), 0.0)));\n  f -= (1.0 - max(sign(16.0 - f), 0.0)) * 16.0;\n  arr[4] = bool(int(1.0 - max(sign(8.0 - f), 0.0)));\n  f -= (1.0 - max(sign(8.0 - f), 0.0)) * 8.0;\n  arr[5] = bool(int(1.0 - max(sign(4.0 - f), 0.0)));\n  f -= (1.0 - max(sign(4.0 - f), 0.0)) * 4.0;\n  arr[6] = bool(int(1.0 - max(sign(2.0 - f), 0.0)));\n  f -= (1.0 - max(sign(2.0 - f), 0.0)) * 2.0;\n  arr[7] = bool(int(1.0 - max(sign(1.0 - f), 0.0)));\n}".trim(),g="\nfloat packBooleans(bool arr[8]) {\n  float f = float(int(arr[0])) * 128.0;\n  f += float(int(arr[1])) * 64.0;\n  f += float(int(arr[2])) * 32.0;\n  f += float(int(arr[3])) * 16.0;\n  f += float(int(arr[4])) * 8.0;\n  f += float(int(arr[5])) * 4.0;\n  f += float(int(arr[6])) * 2.0;\n  return (f + float(int(arr[7]))) / 255.0;\n}".trim();i.functionStrings={round:f,vec2ToInt16:T,int16ToVec2:l,vec2ToUint16:s,uint16ToVec2:u,unpackBooleans:d,packBooleans:g},i.expandDefinitions=function(n){return a.expandDefinitions(n)}},function(n,i,t){"use strict";Object.defineProperty(i,"__esModule",{value:!0}),i.RenderTarget=void 0;const e=t(0),o=t(11),r=t(4);class a{constructor(n,i){const t=e.getMaxRenderBufferSize();if(!Number.isInteger(n)||n<1||n>t)throw new Error(`ComputeTarget width of '${n}' is out of range (1 to ${t})`);if(Math.log(n)/Math.log(2)%1!=0)throw new Error(`ComputeTarget width of '${n}' is not a power of two`);this.width=n,this.targetAlpha=i||this.createTarget()}compute(n,i){const t=e.getWebGLContext();return t.useProgram(n.program),this.setBuffers(n,r.getComputeBufferInfo()),i&&this.setUniforms(n,i),t.bindFramebuffer(t.FRAMEBUFFER,this.targetAlpha.framebuffer),t.viewport(0,0,this.width,this.width),t.drawArrays(t.TRIANGLES,0,6),this}transpose(n){if(n.width!==this.width)throw new Error(`scatterFragCoord width: '${n.width}' != RenderTarget width: '${this.width}'`);const i=e.getWebGLContext(),t=o.getTransposeShader();return i.useProgram(t.program),this.setBuffers(t,o.getTransposeBufferInfo(this.width)),this.setUniforms(t,{u_scatterCoord:n,u_sourceTex:this,u_textureWidth:this.width}),i.bindFramebuffer(i.FRAMEBUFFER,this.targetAlpha.framebuffer),i.viewport(0,0,this.width,this.width),i.drawArrays(i.POINTS,0,this.width*this.width),this}pushSomePixels(n,i,t,o,r){if(r.length!==t*o*4)throw new Error("out.length !== "+t*o*4);const a=e.getWebGLContext();a.bindTexture(a.TEXTURE_2D,this.targetAlpha.texture),a.texSubImage2D(a.TEXTURE_2D,0,n,i,t,o,a.RGBA,a.UNSIGNED_BYTE,r),a.bindTexture(a.TEXTURE_2D,null)}pushPixelsRecursively(n,i,t,e,o,r,a){const f=Math.min(Math.max(Math.floor(o/t),1),e);if(this.pushSomePixels(n,i,t,f,r.subarray(0,4*t*f)),e-f<=0)return a();requestAnimationFrame(()=>this.pushPixelsRecursively(n,i+f,t,e-f,o,r.subarray(4*t*f),a))}pushSomePixelsAsync(n,i,t,e,o){return new Promise((r,a)=>{if(o.length!==t*e*4)return a(new Error("out.length !== "+t*e*4));this.pushPixelsRecursively(n,i,t,e,262144,o,()=>r())})}pushTextureData(n){const i=this.width,t=n.length/4,e=4*(t-t%i);if(n.length>4*i*i)throw new Error(`array length of: '${n.length}' overflows: '${4*i*i}'`);if(n.length%4>0)throw new Error(`array length of: '${n.length}' is not a multiple of four`);if(i>=t)return this.pushSomePixels(0,0,Math.min(t,i),Math.max(Math.floor(t/i),1),n);this.pushSomePixels(0,0,Math.min(t,i),Math.max(Math.floor(t/i),1),n.subarray(0,e)),4*i*i>n.length&&this.pushSomePixels(0,Math.floor(t/i),t%i,1,n.subarray(e))}pushTextureDataAsync(n){return new Promise((i,t)=>{const e=this.width,o=n.length/4,r=4*(o-o%e);return n.length>4*e*e?t(new Error(`array length of: '${n.length}' overflows: '${4*e*e}'`)):n.length%4>0?t(new Error(`array length of: '${n.length}' is not a multiple of four`)):void(e>=o?this.pushSomePixelsAsync(0,0,Math.min(o,e),Math.max(Math.floor(o/e),1),n).then(()=>i()).catch(n=>t(n)):4*e*e>n.length?this.pushSomePixelsAsync(0,0,Math.min(o,e),Math.max(Math.floor(o/e),1),n.subarray(0,r)).then(()=>this.pushSomePixelsAsync(0,Math.floor(o/this.width),o%this.width,1,n.subarray(r)).then(()=>i()).catch(n=>t(n))).catch(n=>t(n)):this.pushSomePixelsAsync(0,0,Math.min(o,e),Math.max(Math.floor(o/e),1),n.subarray(0,r)).then(()=>i()).catch(n=>t(n)))})}readPixels(n){return this.readSomePixels(0,0,this.width,this.width,n)}readPixelsAsync(n){return this.readSomePixelsAsync(0,0,this.width,this.width,n)}readSomePixels(n,i,t,o,r){r||(r=new Uint8Array(t*o*4));const a=e.getWebGLContext();return a.bindFramebuffer(a.FRAMEBUFFER,this.targetAlpha.framebuffer),a.readPixels(n,i,t,o,a.RGBA,a.UNSIGNED_BYTE,r),a.bindFramebuffer(a.FRAMEBUFFER,null),r}readPixelsRecursively(n,i,t,e,o,r,a){const f=Math.min(Math.max(Math.floor(o/t),1),e);if(this.readSomePixels(n,i,t,f,r.subarray(0,4*t*f)),e-f<=0)return a();requestAnimationFrame(()=>this.readPixelsRecursively(n,i+f,t,e-f,o,r.subarray(4*t*f),a))}readSomePixelsAsync(n,i,t,e,o){return new Promise((r,a)=>{if(o||(o=new Uint8Array(t*e*4)),o.length!==t*e*4)return a(new Error("out.length !== "+t*e*4));this.readPixelsRecursively(n,i,t,e,262144,o,()=>r(o))})}delete(){const n=e.getWebGLContext();n.deleteTexture(this.targetAlpha.texture),n.deleteFramebuffer(this.targetAlpha.framebuffer),this.targetBravo&&(n.deleteTexture(this.targetBravo.texture),n.deleteFramebuffer(this.targetBravo.framebuffer))}getBackbuffer(){return this.targetBravo?new a(this.width,this.targetBravo):null}deleteBackbuffer(){if(this.targetBravo){const n=e.getWebGLContext();n.deleteTexture(this.targetBravo.texture),n.deleteFramebuffer(this.targetBravo.framebuffer)}}setBuffers(n,i){const t=e.getWebGLContext();for(var o in i){const e=i[o].buffer,r=i[o].numComponents,a=n.attributeInfo[o].location;t.bindBuffer(t.ARRAY_BUFFER,e),t.enableVertexAttribArray(a),t.vertexAttribPointer(a,r,t.FLOAT,!1,0,0),t.bindBuffer(t.ARRAY_BUFFER,null)}}setUniforms(n,i){let t=0,o=!1;const r=e.getWebGLContext();for(let e in n.uniformInfo){if(void 0===i[e])continue;if(n.uniformInfo[e].type!==r.SAMPLER_2D)continue;const a=i[e];if(a.targetAlpha.texture===this.targetAlpha.texture&&(o||t++,o=!0),this.targetBravo&&this.targetBravo.texture===a.targetAlpha.texture)throw new Error(`provided uniform: '${e}' cannot be the RenderTarget's backbuffer`)}for(let e in n.uniformInfo){if(void 0===i[e])continue;const o=i[e],a=n.uniformInfo[e].type,f=n.uniformInfo[e].location;switch(a){case r.SAMPLER_2D:if(Array.isArray(o)||"number"==typeof o)throw new Error(`provided uniform: '${e}' is not a WebGLTexture`);r.uniform1i(f,t),r.activeTexture(r.TEXTURE0+t++),r.bindTexture(r.TEXTURE_2D,o.targetAlpha.texture);break;case r.FLOAT:"number"==typeof o?r.uniform1f(f,o):Array.isArray(o)&&r.uniform1fv(f,o);break;case r.FLOAT_VEC2:case r.FLOAT_VEC3:case r.FLOAT_VEC4:throw new Error("uniform vectors are currently unsupported");default:throw new Error(`unsupported uniform type: '${a}'`)}}o&&(this.targetBravo||(this.targetBravo=this.createTarget()),[this.targetAlpha,this.targetBravo]=[this.targetBravo,this.targetAlpha])}createTarget(){const n=e.getWebGLContext(),i=n.createFramebuffer();if(!i)throw new Error("unable to create framebuffer");const t=n.createTexture();if(!t)throw new Error("unable to create texture");return n.bindFramebuffer(n.FRAMEBUFFER,i),n.activeTexture(n.TEXTURE0),n.bindTexture(n.TEXTURE_2D,t),n.texImage2D(n.TEXTURE_2D,0,n.RGBA,this.width,this.width,0,n.RGBA,n.UNSIGNED_BYTE,null),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MAG_FILTER,n.NEAREST),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MIN_FILTER,n.NEAREST),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,t,0),n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),{framebuffer:i,texture:t}}}i.RenderTarget=a},function(n,i,t){"use strict";Object.defineProperty(i,"__esModule",{value:!0}),i.getComputeBufferInfo=i.createBufferInfoFromArrays=void 0;const e=t(0);function o(n){const i=e.getWebGLContext(),t={};for(let e in n){const o=i.createBuffer();if(null===o)throw new Error("unable to create buffer");t[e]={buffer:o,numComponents:n[e].numComponents}}for(let e in t)i.bindBuffer(i.ARRAY_BUFFER,t[e].buffer),i.bufferData(i.ARRAY_BUFFER,n[e].data,i.STATIC_DRAW);return i.bindBuffer(i.ARRAY_BUFFER,null),t}var r;i.createBufferInfoFromArrays=o,i.getComputeBufferInfo=function(){return r||(r=o({a_position:{data:new Float32Array([-1,-1,1,-1,-1,1,-1,1,1,-1,1,1]),numComponents:2}})),r}},function(n,i,t){"use strict";function e(n){for(let i=0;i<n.length;i++)n[i]=255-n[i]}function o(n){let i=1;for(let t=0;t<n.length;t++){let e=n[t]+i;e<=255&&(i=0),n[t]=e%256}}Object.defineProperty(i,"__esModule",{value:!0}),i.resizeBytes=i.hexToBytes=i.bytesToHex=i.removeTwosComplement=i.applyTwosComplement=i.addOne=i.flipBits=void 0,i.flipBits=e,i.addOne=o,i.applyTwosComplement=function(n,i){n[n.length-1]>=128&&(n[n.length-1]-=128),i&&(e(n),o(n))},i.removeTwosComplement=function(n){const i=n[n.length-1]>=128;return i&&(e(n),o(n)),i};const r=Array.from(Array(16),(n,i)=>i.toString(16));i.bytesToHex=function(n){let i="";for(let t=n.length-1;t>=0;t--){const e=n[t];i+=r[Math.floor(e/16)],i+=r[e%16]}return i};const a={};r.forEach((n,i)=>a[n]=i),i.hexToBytes=function(n){n.length%2&&(n="0"+n);const i=new Uint8Array(n.length/2);for(let t=0;t<i.length;t++){const e=16*a[n[2*t]],o=a[n[2*t+1]];i[i.length-t-1]=e+o}return i},i.resizeBytes=function(n,i,t){return n.length===i?n:n.length>i?t?n.subarray(n.length-i):n.subarray(0,i):t?new Uint8Array([...Array(i-n.length).fill(0),...n]):new Uint8Array([...n,...Array(i-n.length).fill(0)])}},function(n,i,t){"use strict";function e(n,i,t){let e=0;const o=[],r=(n,a)=>{for(let[o,f]of Object.entries(i))for(let i of f.declarations)if(a.includes("\n"+i)){if(e++>1e6)throw new Error(`dependency loop: ${n} ${o}`);r(o,t[o])}n&&!o.includes(n)&&o.push(n)};return r(null,n),o}function o(n,i){for(let t of Object.values(i))for(let i of t.declarations)for(;n.includes("\n"+i);)n=n.replace("\n"+i,"\n");return n}function r(n,i,t,e){let r="";for(let n of i)r+=t[n].prepend+"\n\n",r+=o(e[n],t)+"\n\n",r+=t[n].append+"\n\n";return r+n}function a(n,i){for(let t of i){const i=n.search(t),e=n.substring(0,i+t.length);let o=n.substring(i);for(;o.includes(t);)o=o.replace(t,"");return e+o}return n}Object.defineProperty(i,"__esModule",{value:!0}),i.replaceDefinitions=i.renderDefinitions=i.removeStutters=i.removeDependencies=i.findDependencies=void 0,i.findDependencies=e,i.removeDependencies=o,i.removeStutters=a,i.renderDefinitions=function(n,i,t){const f={};for(let T of Object.keys(n)){const l=e(n[T],i,n);f[T]=r(n[T],l,i,n),f[T]=o(f[T],i),t&&(f[T]=a(f[T],t)),f[T]=`${i[T].prepend}\n\n${f[T]}`,f[T]=`${f[T]}\n\n${i[T].append}`,f[T]=f[T].replace(/\n{3,}/g,"\n\n")}return f},i.replaceDefinitions=function(n,i,t){const e=[];for(let[o,r]of Object.entries(t))for(let t of r.declarations)n.includes("\n"+t)&&(e.includes(o)?n=n.replace("\n"+t,"\n"):(n=n.replace("\n"+t,"\n\n"+i[o]),e.push(o)));return n}},function(n,i,t){"use strict";Object.defineProperty(i,"__esModule",{value:!0}),i.packBooleans=i.unpackBooleans=void 0,i.unpackBooleans=function(n){var i=new Array(8);n=Math.min(Math.max(0,Math.round(n)),255);for(var t=0;t<8;t++){var e=Math.pow(2,7-t);n>=e?(i[t]=!0,n-=e):i[t]=!1}return i},i.packBooleans=function(n){for(var i=0,t=0;t<8;t++)n.length>t&&n[t]&&(i+=Math.pow(2,7-t));return i}},function(n,i,t){"use strict";Object.defineProperty(i,"__esModule",{value:!0}),i.packInt16=i.unpackInt16=i.MIN_INT16=i.MAX_INT16=void 0,i.MAX_INT16=32768,i.MIN_INT16=-32767,i.unpackInt16=function(n,i){return 256*(n=Math.min(Math.max(0,Math.floor(n)),255))+(i=Math.min(Math.max(0,Math.floor(i)),255))-32767},i.packInt16=function(n){var i=new Array(2);return n=Math.min(Math.max(-32767,Math.round(n)),32768)+32767,i[0]=Math.floor(n/256),i[1]=n-256*i[0],i}},function(n,i,t){"use strict";Object.defineProperty(i,"__esModule",{value:!0}),i.packUint16=i.unpackUint16=i.MIN_UINT16=i.MAX_UINT16=void 0,i.MAX_UINT16=65535,i.MIN_UINT16=0,i.unpackUint16=function(n,i){return 256*(n=Math.min(Math.max(0,Math.floor(n)),255))+(i=Math.min(Math.max(0,Math.floor(i)),255))},i.packUint16=function(n){var i=new Array(2);return n=Math.min(Math.max(0,Math.round(n)),65535),i[0]=Math.floor(n/256),i[1]=n-256*i[0],i}},function(n,i,t){"use strict";Object.defineProperty(i,"__esModule",{value:!0});const e=t(0),o=t(1),r=t(3),a=t(7),f=t(8),T=t(9),l=t(2);n.exports={setWebGLContext:e.setWebGLContext,getWebGLContext:e.getWebGLContext,isWebGL2:e.isWebGL2,ComputeShader:o.ComputeShader,passThruFrag:o.passThruFrag,passThruVert:o.passThruVert,RenderTarget:r.RenderTarget,packBooleans:a.packBooleans,unpackBooleans:a.unpackBooleans,packInt16:f.packInt16,unpackInt16:f.unpackInt16,MIN_INT16:f.MIN_INT16,MAX_INT16:f.MAX_INT16,packUint16:T.packUint16,unpackUint16:T.unpackUint16,MIN_UINT16:T.MIN_UINT16,MAX_UINT16:T.MAX_UINT16,functionStrings:l.functionStrings,expandDefinitions:l.expandDefinitions};var s=t(0);Object.defineProperty(i,"setWebGLContext",{enumerable:!0,get:function(){return s.setWebGLContext}}),Object.defineProperty(i,"getWebGLContext",{enumerable:!0,get:function(){return s.getWebGLContext}}),Object.defineProperty(i,"isWebGL2",{enumerable:!0,get:function(){return s.isWebGL2}});var u=t(1);Object.defineProperty(i,"ComputeShader",{enumerable:!0,get:function(){return u.ComputeShader}}),Object.defineProperty(i,"passThruFrag",{enumerable:!0,get:function(){return u.passThruFrag}}),Object.defineProperty(i,"passThruVert",{enumerable:!0,get:function(){return u.passThruVert}});var d=t(3);Object.defineProperty(i,"RenderTarget",{enumerable:!0,get:function(){return d.RenderTarget}});var g=t(7);Object.defineProperty(i,"packBooleans",{enumerable:!0,get:function(){return g.packBooleans}}),Object.defineProperty(i,"unpackBooleans",{enumerable:!0,get:function(){return g.unpackBooleans}});var b=t(8);Object.defineProperty(i,"packInt16",{enumerable:!0,get:function(){return b.packInt16}}),Object.defineProperty(i,"unpackInt16",{enumerable:!0,get:function(){return b.unpackInt16}}),Object.defineProperty(i,"MIN_INT16",{enumerable:!0,get:function(){return b.MIN_INT16}}),Object.defineProperty(i,"MAX_INT16",{enumerable:!0,get:function(){return b.MAX_INT16}});var _=t(9);Object.defineProperty(i,"packUint16",{enumerable:!0,get:function(){return _.packUint16}}),Object.defineProperty(i,"unpackUint16",{enumerable:!0,get:function(){return _.unpackUint16}}),Object.defineProperty(i,"MIN_UINT16",{enumerable:!0,get:function(){return _.MIN_UINT16}}),Object.defineProperty(i,"MAX_UINT16",{enumerable:!0,get:function(){return _.MAX_UINT16}});var E=t(2);Object.defineProperty(i,"functionStrings",{enumerable:!0,get:function(){return E.functionStrings}}),Object.defineProperty(i,"expandDefinitions",{enumerable:!0,get:function(){return E.expandDefinitions}})},function(n,i,t){"use strict";Object.defineProperty(i,"__esModule",{value:!0}),i.getTransposeShader=i.getTransposeBufferInfo=i.passThruTransposeFrag=i.passThruTransposeVert=void 0;const e=t(0),o=t(4),r=t(1),a=t(2);i.passThruTransposeVert="\n#ifdef GL_ES\nprecision mediump float;\nprecision mediump int;\nprecision mediump sampler2D;\n#endif\n\nuniform sampler2D u_scatterCoord;\nuniform sampler2D u_sourceTex;\nuniform float u_textureWidth;\nattribute vec2 a_position;\nvarying vec4 v_sourceTexel;\n\nfloat vec2ToUint16(vec2 v);\n\nvoid main() {\n  gl_PointSize = 1.0;\n  vec4 destinationTexel = texture2D(u_scatterCoord, vec2(a_position.x + 1.0, a_position.y + 1.0) / 2.0);\n  vec2 destinationCoord = vec2(vec2ToUint16(destinationTexel.rg) + 0.5, vec2ToUint16(destinationTexel.ba) + 0.5);\n  gl_Position = vec4(2.0 * (destinationCoord.xy / u_textureWidth) - vec2(1.0, 1.0), 0.0, 1.0);\n  v_sourceTexel = texture2D(u_sourceTex, vec2(a_position.x + 1.0, a_position.y + 1.0) / 2.0);\n}",i.passThruTransposeFrag="\n#ifdef GL_ES\nprecision mediump float;\nprecision mediump int;\nprecision mediump sampler2D;\n#endif\n\nvarying vec4 v_sourceTexel;\n\nvoid main() {\n  gl_FragColor = v_sourceTexel;\n}";const f=new Array(13);var T;i.getTransposeBufferInfo=function(n){if(n<2||n>4096)throw new Error(`width of '${n}' is out of range (2 to 4096)`);const i=Math.log(n)/Math.log(2);if(i%1!=0)throw new Error(`width of '${n}' is not a power of two`);if(!f[i]){const n=Math.pow(2,i),a=new Float32Array(2*n*n);for(var t=0,e=0;e<n;e++)for(var r=0;r<n;r++)a[t++]=2*(r+.5)/n-1,a[t++]=2*(e+.5)/n-1;const T=o.createBufferInfoFromArrays({a_position:{data:a,numComponents:2}});f[i]=T}return f[i]},i.getTransposeShader=function(){if(T)return T;const n=e.getWebGLContext(),t=n.getParameter(n.MAX_VERTEX_TEXTURE_IMAGE_UNITS);if(t<2)throw new Error(`MAX_VERTEX_TEXTURE_IMAGE_UNITS: '${t}' is less than 2`);const o={"float vec2ToUint16(vec2 v);":a.functionStrings.vec2ToUint16};return T=new r.ComputeShader(i.passThruTransposeFrag,o,i.passThruTransposeVert)}},function(n,i,t){"use strict";var e=Object.create?function(n,i,t,e){void 0===e&&(e=t),Object.defineProperty(n,e,{enumerable:!0,get:function(){return i[t]}})}:function(n,i,t,e){void 0===e&&(e=t),n[e]=i[t]},o=Object.create?function(n,i){Object.defineProperty(n,"default",{enumerable:!0,value:i})}:function(n,i){n.default=i},r=function(n){if(n&&n.__esModule)return n;var i={};if(null!=n)for(var t in n)Object.hasOwnProperty.call(n,t)&&e(i,n,t);return o(i,n),i};Object.defineProperty(i,"__esModule",{value:!0}),i.expandDefinitions=i.declarations=i.untouchedFunctionStrings=i.functionStrings=i.encodeSignedBytes=i.decodeSignedBytes=void 0;const a=r(t(13)),f=t(6),T=t(5);i.decodeSignedBytes=function(n,i){const t=T.removeTwosComplement(n);i&&n.reverse();const e=BigInt("0x"+T.bytesToHex(n))*(t?BigInt(-1):BigInt(1));return T.applyTwosComplement(n,t),e},i.encodeSignedBytes=function(n,i,t){const e=n<BigInt(0);e&&(n*=BigInt(-1));const o=T.resizeBytes(T.hexToBytes(n.toString(16)),i,t);return T.applyTwosComplement(o,e),t&&o.reverse(),o},i.functionStrings={bigintAbs:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nbool bigintRemoveTwosComplement(inout float [BYTE_COUNT]);\nvoid bigintApplyTwosComplement(inout float [BYTE_COUNT], bool);\n\nvoid bigintAbs(inout float a[BYTE_COUNT]) {\n    bigintRemoveTwosComplement(a);\n    bigintApplyTwosComplement(a, false);\n}",bigintAdd:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nvoid biguintAdd(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);\nvoid bigintAssign(inout float [BYTE_COUNT], float);\n\nvoid bigintAdd(float a[BYTE_COUNT], float b[BYTE_COUNT], inout float c[BYTE_COUNT]) {\n    biguintAdd(a, b, c);\n}\n\nvoid bigintAdd(float a[BYTE_COUNT], float bf, inout float c[BYTE_COUNT]) {\n    float b[BYTE_COUNT];\n    bigintAssign(b, bf);\n    bigintAdd(a, b, c);\n}",bigintAnd:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nvoid biguintAnd(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);\n\nvoid bigintAnd(float a[BYTE_COUNT], float b[BYTE_COUNT], inout float c[BYTE_COUNT]) {\n    biguintAnd(a, b, c);\n}",bigintApplyTwosComplement:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nvoid biguintAdd(float [BYTE_COUNT], float, inout float [BYTE_COUNT]);\n\nvoid bigintApplyTwosComplement(inout float a[BYTE_COUNT], float negative) {\n    a[BYTE_COUNT-1] -= float(a[BYTE_COUNT-1] >= 128.0) * 128.0;\n    for (int i = 0; i < BYTE_COUNT; i++) {\n        a[i] = a[i] * (1.0 - negative)\n             + (255.0 - a[i]) * negative;\n    }\n    biguintAdd(a, negative, a);\n}\n\nvoid bigintApplyTwosComplement(inout float a[BYTE_COUNT], bool negative) {\n    bigintApplyTwosComplement(a, float(negative));\n}",bigintAssign:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nvoid bigintApplyTwosComplement(inout float [BYTE_COUNT], float);\n\nvoid bigintAssign(inout float dst[BYTE_COUNT], float src[BYTE_COUNT]) {\n    for (int i = 0; i < BYTE_COUNT; i++) dst[i] = src[i];\n}\n\nvoid bigintAssign(inout float dst[BYTE_COUNT], float f) {\n    float isNegative = float(f < 0.0);\n    f = min(abs(floor(f)), 65535.0);\n    dst[0] = mod(f, 256.0);\n    dst[1] = floor(f / 256.0);\n    for (int i = 2; i < BYTE_COUNT; i++) dst[i] = 0.0;\n    bigintApplyTwosComplement(dst, isNegative);\n}",bigintAssignIfTrue:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nvoid bigintAssign(inout float [BYTE_COUNT], float);\n\nvoid bigintAssignIfTrue(inout float dst[BYTE_COUNT], float src[BYTE_COUNT], float f) {\n    for (int i = 0; i < BYTE_COUNT; i++)\n       dst[i] = src[i] * float(f != 0.0)\n              + dst[i] * float(f == 0.0);\n}\n\nvoid bigintAssignIfTrue(inout float dst[BYTE_COUNT], float src[BYTE_COUNT], bool b) {\n    bigintAssignIfTrue(dst, src, float(b));\n}\n\nvoid bigintAssignIfTrue(inout float dst[BYTE_COUNT], float sf, float f) {\n    float src[BYTE_COUNT];\n    bigintAssign(dst, sf);\n    bigintAssignIfTrue(dst, src, f);\n}\n\nvoid bigintAssignIfTrue(inout float dst[BYTE_COUNT], float sf, bool b) {\n    float src[BYTE_COUNT];\n    bigintAssign(dst, sf);\n    bigintAssignIfTrue(dst, src, float(b));\n}",bigintDiv:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nbool bigintRemoveTwosComplement(inout float [BYTE_COUNT]);\nvoid biguintDiv(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);\nvoid bigintApplyTwosComplement(inout float [BYTE_COUNT], bool);\nvoid bigintAssign(inout float [BYTE_COUNT], float);\n\nvoid bigintDiv(float a[BYTE_COUNT], float b[BYTE_COUNT], inout float c[BYTE_COUNT]) {\n    bool aNegative = bigintRemoveTwosComplement(a);\n    bool bNegative = bigintRemoveTwosComplement(b);\n    biguintDiv(a, b, c);\n    bigintApplyTwosComplement(c, aNegative != bNegative);\n}\n\nvoid bigintDiv(float a[BYTE_COUNT], float bf, inout float c[BYTE_COUNT]) {\n    float b[BYTE_COUNT];\n    bigintAssign(b, bf);\n    bigintDiv(a, b, c);\n}",bigintEquals:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nbool bigintRemoveTwosComplement(inout float [BYTE_COUNT]);\nvoid bigintAssign(inout float [BYTE_COUNT], float);\n\nfloat bigintEquals(float a[BYTE_COUNT], float b[BYTE_COUNT]) {\n    float cmp;\n    bool aNegative = bigintRemoveTwosComplement(a);\n    bool bNegative = bigintRemoveTwosComplement(b);\n    cmp += float(aNegative == false && bNegative == true);\n    cmp -= float(aNegative == true && bNegative == false);\n    for (int i = BYTE_COUNT - 1; i >= 0; i--)\n        cmp += float(cmp == 0.0) * float(a[i] > b[i])\n             - float(cmp == 0.0) * float(a[i] < b[i]);\n    return float(cmp == 0.0);\n}\n\nfloat bigintEquals(float a[BYTE_COUNT], float bf) {\n    float b[BYTE_COUNT];\n    bigintAssign(b, bf);\n    return bigintEquals(a, b);\n}",bigintGreaterThan:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nbool bigintRemoveTwosComplement(inout float [BYTE_COUNT]);\nvoid bigintAssign(inout float [BYTE_COUNT], float);\n\nfloat bigintGreaterThan(float a[BYTE_COUNT], float b[BYTE_COUNT]) {\n    float cmp;\n    bool aNegative = bigintRemoveTwosComplement(a);\n    bool bNegative = bigintRemoveTwosComplement(b);\n    cmp += float(aNegative == false && bNegative == true);\n    cmp -= float(aNegative == true && bNegative == false);\n    for (int i = BYTE_COUNT - 1; i >= 0; i--) {\n        cmp += float(cmp == 0.0) * float(a[i] > b[i]);\n        cmp -= float(cmp == 0.0) * float(a[i] < b[i]);\n    }\n    return float(cmp > 0.0);\n}\n\nfloat bigintGreaterThan(float a[BYTE_COUNT], float bf) {\n    float b[BYTE_COUNT];\n    bigintAssign(b, bf);\n    return bigintGreaterThan(a, b);\n}",bigintGreaterThanOrEqual:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nbool bigintRemoveTwosComplement(inout float [BYTE_COUNT]);\nvoid bigintAssign(inout float [BYTE_COUNT], float);\n\nfloat bigintGreaterThanOrEqual(float a[BYTE_COUNT], float b[BYTE_COUNT]) {\n    float cmp;\n    bool aNegative = bigintRemoveTwosComplement(a);\n    bool bNegative = bigintRemoveTwosComplement(b);\n    cmp += float(aNegative == false && bNegative == true);\n    cmp -= float(aNegative == true && bNegative == false);\n    for (int i = BYTE_COUNT - 1; i >= 0; i--) {\n        cmp += float(cmp == 0.0) * float(a[i] > b[i]);\n        cmp -= float(cmp == 0.0) * float(a[i] < b[i]);\n    }\n    return float(cmp >= 0.0);\n}\n\nfloat bigintGreaterThanOrEqual(float a[BYTE_COUNT], float bf) {\n    float b[BYTE_COUNT];\n    bigintAssign(b, bf);\n    return bigintGreaterThanOrEqual(a, b);\n}",bigintLessThan:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nbool bigintRemoveTwosComplement(inout float [BYTE_COUNT]);\nvoid bigintAssign(inout float [BYTE_COUNT], float);\n\nfloat bigintLessThan(float a[BYTE_COUNT], float b[BYTE_COUNT]) {\n    float cmp;\n    bool aNegative = bigintRemoveTwosComplement(a);\n    bool bNegative = bigintRemoveTwosComplement(b);\n    cmp += float(aNegative == false && bNegative == true);\n    cmp -= float(aNegative == true && bNegative == false);\n    for (int i = BYTE_COUNT - 1; i >= 0; i--) {\n        cmp += float(cmp == 0.0) * float(a[i] > b[i]);\n        cmp -= float(cmp == 0.0) * float(a[i] < b[i]);\n    }\n    return float(cmp < 0.0);\n}\n\nfloat bigintLessThan(float a[BYTE_COUNT], float bf) {\n    float b[BYTE_COUNT];\n    bigintAssign(b, bf);\n    return bigintLessThan(a, b);\n}\n",bigintLessThanOrEqual:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nbool bigintRemoveTwosComplement(inout float [BYTE_COUNT]);\nvoid bigintAssign(inout float [BYTE_COUNT], float);\n\nfloat bigintLessThanOrEqual(float a[BYTE_COUNT], float b[BYTE_COUNT]) {\n    float cmp;\n    bool aNegative = bigintRemoveTwosComplement(a);\n    bool bNegative = bigintRemoveTwosComplement(b);\n    cmp += float(aNegative == false && bNegative == true);\n    cmp -= float(aNegative == true && bNegative == false);\n    for (int i = BYTE_COUNT - 1; i >= 0; i--) {\n        cmp += float(cmp == 0.0) * float(a[i] > b[i]);\n        cmp -= float(cmp == 0.0) * float(a[i] < b[i]);\n    }\n    return float(cmp <= 0.0);\n}\n\nfloat bigintLessThanOrEqual(float a[BYTE_COUNT], float bf) {\n    float b[BYTE_COUNT];\n    bigintAssign(b, bf);\n    return bigintLessThanOrEqual(a, b);\n}",bigintLshift:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nbool bigintRemoveTwosComplement(inout float [BYTE_COUNT]);\nvoid biguintLshift(float [BYTE_COUNT], inout float [BYTE_COUNT], float);\nvoid bigintApplyTwosComplement(inout float [BYTE_COUNT], bool);\n\nvoid bigintLshift(float a[BYTE_COUNT], inout float b[BYTE_COUNT], float f) {\n    bool negative = bigintRemoveTwosComplement(a);\n    biguintLshift(a, b, f);\n    bigintApplyTwosComplement(b, negative);\n}",bigintLshiftByOne:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nbool bigintRemoveTwosComplement(inout float [BYTE_COUNT]);\nvoid biguintLshiftByOne(inout float [BYTE_COUNT]);\nvoid bigintApplyTwosComplement(inout float [BYTE_COUNT], bool);\n\nvoid bigintLshiftByOne(inout float a[BYTE_COUNT]) {\n    bool negative = bigintRemoveTwosComplement(a);\n    biguintLshiftByOne(a);\n    bigintApplyTwosComplement(a, negative);\n}",bigintMul:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nbool bigintRemoveTwosComplement(inout float [BYTE_COUNT]);\nvoid biguintMul(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);\nvoid bigintApplyTwosComplement(inout float [BYTE_COUNT], bool);\nvoid bigintAssign(inout float [BYTE_COUNT], float);\n\nvoid bigintMul(float a[BYTE_COUNT], float b[BYTE_COUNT], inout float c[BYTE_COUNT]) {\n    bool aNegative = bigintRemoveTwosComplement(a);\n    bool bNegative = bigintRemoveTwosComplement(b);\n    biguintMul(a, b, c);\n    bigintApplyTwosComplement(c, aNegative != bNegative);\n}\n\nvoid bigintMul(float a[BYTE_COUNT], float bf, inout float c[BYTE_COUNT]) {\n    float b[BYTE_COUNT];\n    bigintAssign(b, bf);\n    bigintMul(a, b, c);\n}",bigintOr:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nvoid biguintOr(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);\n\nvoid bigintOr(float a[BYTE_COUNT], float b[BYTE_COUNT], inout float c[BYTE_COUNT]) {\n    biguintOr(a, b, c);\n}",bigintRemoveTwosComplement:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nvoid biguintAdd(float [BYTE_COUNT], float, inout float [BYTE_COUNT]);\n\nbool bigintRemoveTwosComplement(inout float a[BYTE_COUNT]) {\n    float negative = float(a[BYTE_COUNT-1] >= 128.0);\n    for (int i = 0; i < BYTE_COUNT; i++) {\n        a[i] = a[i] * (1.0 - negative)\n             + (255.0 - a[i]) * negative;\n    }\n    biguintAdd(a, negative, a);\n    return bool(negative);\n}",bigintRshift:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nbool bigintRemoveTwosComplement(inout float [BYTE_COUNT]);\nvoid biguintRshift(float [BYTE_COUNT], inout float [BYTE_COUNT], float);\nvoid bigintApplyTwosComplement(inout float [BYTE_COUNT], bool);\n\nvoid bigintRshift(float a[BYTE_COUNT], inout float b[BYTE_COUNT], float f) {\n    bool negative = bigintRemoveTwosComplement(a);\n    biguintRshift(a, b, f);\n    bigintApplyTwosComplement(b, negative);\n}",bigintRshiftByOne:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nbool bigintRemoveTwosComplement(inout float [BYTE_COUNT]);\nvoid biguintRshiftByOne(float [BYTE_COUNT]);\nvoid bigintApplyTwosComplement(inout float [BYTE_COUNT], bool);\n\nvoid bigintRshiftByOne(inout float a[BYTE_COUNT]) {\n    bool negative = bigintRemoveTwosComplement(a);\n    biguintRshiftByOne(a);\n    bigintApplyTwosComplement(a, negative);\n}",bigintSub:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nvoid biguintSub(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);\nvoid bigintAssign(inout float [BYTE_COUNT], float);\n\nvoid bigintSub(float a[BYTE_COUNT], float b[BYTE_COUNT], inout float c[BYTE_COUNT]) {\n    biguintSub(a, b, c);\n}\n\nvoid bigintSub(float a[BYTE_COUNT], float bf, inout float c[BYTE_COUNT]) {\n    float b[BYTE_COUNT];\n    bigintAssign(b, bf);\n    bigintSub(a, b, c);\n}",bigintXor:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nvoid biguintXor(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);\n\nvoid bigintXor(float a[BYTE_COUNT], float b[BYTE_COUNT], inout float c[BYTE_COUNT]) {\n    biguintXor(a, b, c);\n}"},Object.keys(i.functionStrings).forEach(n=>{const t=i.functionStrings;t[n]=t[n].replace(/\r+/gm,"").replace(/\t/g,"    ").replace(/\n{3,}/g,"\n\n")}),Object.assign(i.functionStrings,a.untouchedFunctionStrings),i.untouchedFunctionStrings=Object.assign({},i.functionStrings),i.declarations={bigintAbs:{prepend:["#ifndef BIG_INT_ABS","#define BIG_INT_ABS"].join("\n"),declarations:["void bigintAbs(inout float [BYTE_COUNT]);"],append:"#endif"},bigintAdd:{prepend:["#ifndef BIG_INT_ADD","#define BIG_INT_ADD"].join("\n"),declarations:["void bigintAdd(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);","void bigintAdd(float [BYTE_COUNT], float, inout float [BYTE_COUNT]);"],append:"#endif"},bigintAnd:{prepend:["#ifndef BIG_INT_AND","#define BIG_INT_AND"].join("\n"),declarations:["void bigintAnd(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);"],append:"#endif"},bigintApplyTwosComplement:{prepend:["#ifndef BIG_INT_APPLY_TWOS_COMPLEMENT","#define BIG_INT_APPLY_TWOS_COMPLEMENT"].join("\n"),declarations:["void bigintApplyTwosComplement(inout float [BYTE_COUNT], float);","void bigintApplyTwosComplement(inout float [BYTE_COUNT], bool);"],append:"#endif"},bigintAssign:{prepend:["#ifndef BIG_INT_ASSIGN","#define BIG_INT_ASSIGN"].join("\n"),declarations:["void bigintAssign(inout float [BYTE_COUNT], float [BYTE_COUNT]);","void bigintAssign(inout float [BYTE_COUNT], float);"],append:"#endif"},bigintAssignIfTrue:{prepend:["#ifndef BIG_INT_ASSIGN_IF_TRUE","#define BIG_INT_ASSIGN_IF_TRUE"].join("\n"),declarations:["void bigintAssignIfTrue(inout float [BYTE_COUNT], float [BYTE_COUNT], float);","void bigintAssignIfTrue(inout float [BYTE_COUNT], float [BYTE_COUNT], bool);","void bigintAssignIfTrue(inout float [BYTE_COUNT], float, float);","void bigintAssignIfTrue(inout float [BYTE_COUNT], float, bool);"],append:"#endif"},bigintDiv:{prepend:["#ifndef BIG_INT_DIV","#define BIG_INT_DIV"].join("\n"),declarations:["void bigintDiv(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);","void bigintDiv(float [BYTE_COUNT], float, inout float [BYTE_COUNT]);"],append:"#endif"},bigintEquals:{prepend:["#ifndef BIG_INT_EQUALS","#define BIG_INT_EQUALS"].join("\n"),declarations:["float bigintEquals(float [BYTE_COUNT], float [BYTE_COUNT]);","float bigintEquals(float [BYTE_COUNT], float);"],append:"#endif"},bigintGreaterThan:{prepend:["#ifndef BIG_INT_GREATER_THAN","#define BIG_INT_GREATER_THAN"].join("\n"),declarations:["float bigintGreaterThan(float [BYTE_COUNT], float [BYTE_COUNT]);","float bigintGreaterThan(float [BYTE_COUNT], float);"],append:"#endif"},bigintGreaterThanOrEqual:{prepend:["#ifndef BIG_INT_GREATER_THAN_OR_EQUAL","#define BIG_INT_GREATER_THAN_OR_EQUAL"].join("\n"),declarations:["float bigintGreaterThanOrEqual(float [BYTE_COUNT], float [BYTE_COUNT]);","float bigintGreaterThanOrEqual(float [BYTE_COUNT], float);"],append:"#endif"},bigintLessThan:{prepend:["#ifndef BIG_INT_LESS_THAN","#define BIG_INT_LESS_THAN"].join("\n"),declarations:["float bigintLessThan(float [BYTE_COUNT], float [BYTE_COUNT]);","float bigintLessThan(float [BYTE_COUNT], float);"],append:"#endif"},bigintLessThanOrEqual:{prepend:["#ifndef BIG_INT_LESS_THAN_OR_EQUAL","#define BIG_INT_LESS_THAN_OR_EQUAL"].join("\n"),declarations:["float bigintLessThanOrEqual(float [BYTE_COUNT], float [BYTE_COUNT]);","float bigintLessThanOrEqual(float [BYTE_COUNT], float);"],append:"#endif"},bigintLshift:{prepend:["#ifndef BIG_INT_LSHIFT","#define BIG_INT_LSHIFT"].join("\n"),declarations:["void bigintLshift(float [BYTE_COUNT], inout float [BYTE_COUNT], float);"],append:"#endif"},bigintLshiftByOne:{prepend:["#ifndef BIG_INT_LSHIFT_BY_ONE","#define BIG_INT_LSHIFT_BY_ONE"].join("\n"),declarations:["void bigintLshiftByOne(inout float [BYTE_COUNT]);"],append:"#endif"},bigintMul:{prepend:["#ifndef BIG_INT_MUL","#define BIG_INT_MUL"].join("\n"),declarations:["void bigintMul(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);","void bigintMul(float [BYTE_COUNT], float, inout float [BYTE_COUNT]);"],append:"#endif"},bigintOr:{prepend:["#ifndef BIG_INT_OR","#define BIG_INT_OR"].join("\n"),declarations:["void bigintOr(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);"],append:"#endif"},bigintRemoveTwosComplement:{prepend:["#ifndef BIG_INT_REMOVE_TWOS_COMPLEMENT","#define BIG_INT_REMOVE_TWOS_COMPLEMENT"].join("\n"),declarations:["bool bigintRemoveTwosComplement(inout float [BYTE_COUNT]);"],append:"#endif"},bigintRshift:{prepend:["#ifndef BIG_INT_RSHIFT","#define BIG_INT_RSHIFT"].join("\n"),declarations:["void bigintRshift(float [BYTE_COUNT], inout float [BYTE_COUNT], float);"],append:"#endif"},bigintRshiftByOne:{prepend:["#ifndef BIG_INT_RSHIFT_BY_ONE","#define BIG_INT_RSHIFT_BY_ONE"].join("\n"),declarations:["void bigintRshiftByOne(inout float [BYTE_COUNT]);"],append:"#endif"},bigintSub:{prepend:["#ifndef BIG_INT_SUB","#define BIG_INT_SUB"].join("\n"),declarations:["void bigintSub(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);","void bigintSub(float [BYTE_COUNT], float, inout float [BYTE_COUNT]);"],append:"#endif"},bigintXor:{prepend:["#ifndef BIG_INT_XOR","#define BIG_INT_XOR"].join("\n"),declarations:["void bigintXor(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);"],append:"#endif"}},Object.assign(i.declarations,a.declarations);const l=[["#ifndef BYTE_COUNT","#define BYTE_COUNT 16","#endif","","#ifdef GL_ES","precision highp float;","precision highp int;","#endif"].join("\n")];Object.assign(i.functionStrings,f.renderDefinitions(i.functionStrings,i.declarations,l)),i.expandDefinitions=function(n){return n=f.replaceDefinitions(n,i.functionStrings,i.declarations),f.removeStutters(n,l).replace(/\n{3,}/g,"\n\n")}},function(n,i,t){"use strict";Object.defineProperty(i,"__esModule",{value:!0}),i.expandDefinitions=i.declarations=i.untouchedFunctionStrings=i.functionStrings=i.encodeUnsignedBytes=i.decodeUnsignedBytes=void 0;const e=t(5),o=t(6);i.decodeUnsignedBytes=function(n,i){return i&&n.reverse(),BigInt("0x"+e.bytesToHex(n))},i.encodeUnsignedBytes=function(n,i){n<BigInt(0)&&(n=BigInt(0));const t=e.hexToBytes(n.toString(16));return i&&t.reverse(),t},i.functionStrings={biguintAdd:"#ifndef BYTE_COUNT\r\n#define BYTE_COUNT 16\r\n#endif\r\n\r\n#ifdef GL_ES\r\nprecision highp float;\r\nprecision highp int;\r\n#endif\r\n\r\nvoid biguintAssign(inout float [BYTE_COUNT], float);\r\n\r\nvoid biguintAdd(float a[BYTE_COUNT], float b[BYTE_COUNT], inout float c[BYTE_COUNT]) {\r\n    float carry, tmp;\r\n    for (int i = 0; i < BYTE_COUNT; i++) {\r\n        tmp = a[i] + b[i] + carry;\r\n        carry = floor(tmp / 256.0);\r\n        c[i] = mod(tmp, 256.0);\r\n    }\r\n}\r\n\r\nvoid biguintAdd(float a[BYTE_COUNT], float bf, inout float c[BYTE_COUNT]) {\r\n    float b[BYTE_COUNT];\r\n    biguintAssign(b, bf);\r\n    biguintAdd(a, b, c);\r\n}",biguintAnd:"#ifndef BYTE_COUNT\r\n#define BYTE_COUNT 16\r\n#endif\r\n\r\n#ifdef GL_ES\r\nprecision highp float;\r\nprecision highp int;\r\n#endif\r\n\r\n#ifndef FLOAT_GTE\r\n#define FLOAT_GTE\r\nfloat gte(float f1, float f2) {\r\n  return 1.0 - max(sign(f2 - f1), 0.0); \r\n}\r\n#endif\r\n\r\nvoid biguintAnd(float a[BYTE_COUNT], float b[BYTE_COUNT], inout float c[BYTE_COUNT]) {\r\n    for (int i = 0; i < BYTE_COUNT; i++) {\r\n        float o = gte(a[i], 128.0) * gte(b[i], 128.0) * 128.0;\r\n        a[i] -= gte(a[i], 128.0) * 128.0;\r\n        b[i] -= gte(b[i], 128.0) * 128.0;\r\n        o += gte(a[i], 64.0) * gte(b[i], 64.0) * 64.0;\r\n        a[i] -= gte(a[i], 64.0) * 64.0;\r\n        b[i] -= gte(b[i], 64.0) * 64.0;\r\n        o += gte(a[i], 32.0) * gte(b[i], 32.0) * 32.0;\r\n        a[i] -= gte(a[i], 32.0) * 32.0;\r\n        b[i] -= gte(b[i], 32.0) * 32.0;\r\n        o += gte(a[i], 16.0) * gte(b[i], 16.0) * 16.0;\r\n        a[i] -= gte(a[i], 16.0) * 16.0;\r\n        b[i] -= gte(b[i], 16.0) * 16.0;\r\n        o += gte(a[i], 8.0) * gte(b[i], 8.0) * 8.0;\r\n        a[i] -= gte(a[i], 8.0) * 8.0;\r\n        b[i] -= gte(b[i], 8.0) * 8.0;\r\n        o += gte(a[i], 4.0) * gte(b[i], 4.0) * 4.0;\r\n        a[i] -= gte(a[i], 4.0) * 4.0;\r\n        b[i] -= gte(b[i], 4.0) * 4.0;\r\n        o += gte(a[i], 2.0) * gte(b[i], 2.0) * 2.0;\r\n        a[i] -= gte(a[i], 2.0) * 2.0;\r\n        b[i] -= gte(b[i], 2.0) * 2.0;\r\n        c[i] = o + gte(a[i], 1.0) * gte(b[i], 1.0);\r\n    }\r\n}",biguintAssign:"#ifndef BYTE_COUNT\r\n#define BYTE_COUNT 16\r\n#endif\r\n\r\n#ifdef GL_ES\r\nprecision highp float;\r\nprecision highp int;\r\n#endif\r\n\r\nvoid biguintAssign(inout float dst[BYTE_COUNT], float src[BYTE_COUNT]) {\r\n    for (int i = 0; i < BYTE_COUNT; i++) dst[i] = src[i];\r\n}\r\n\r\nvoid biguintAssign(inout float dst[BYTE_COUNT], float f) {\r\n    f = clamp(floor(f), 0.0, 65535.0);\r\n    dst[0] = mod(f, 256.0);\r\n    dst[1] = floor(f / 256.0);\r\n    for (int i = 2; i < BYTE_COUNT; i++) dst[i] = 0.0;\r\n}",biguintAssignIfTrue:"#ifndef BYTE_COUNT\r\n#define BYTE_COUNT 16\r\n#endif\r\n\r\n#ifdef GL_ES\r\nprecision highp float;\r\nprecision highp int;\r\n#endif\r\n\r\nvoid biguintAssign(inout float [BYTE_COUNT], float);\r\n\r\nvoid biguintAssignIfTrue(inout float dst[BYTE_COUNT], float src[BYTE_COUNT], float f) {\r\n    for (int i = 0; i < BYTE_COUNT; i++) \r\n        dst[i] = src[i] * float(f != 0.0)\r\n               + dst[i] * float(f == 0.0);\r\n}\r\n\r\nvoid biguintAssignIfTrue(inout float dst[BYTE_COUNT], float src[BYTE_COUNT], bool b) {\r\n    biguintAssignIfTrue(dst, src, float(b));\r\n}\r\n\r\nvoid biguintAssignIfTrue(inout float dst[BYTE_COUNT], float sf, float f) {\r\n    float src[BYTE_COUNT];\r\n    biguintAssign(dst, sf);\r\n    biguintAssignIfTrue(dst, src, f);\r\n}\r\n\r\nvoid biguintAssignIfTrue(inout float dst[BYTE_COUNT], float sf, bool b) {\r\n    float src[BYTE_COUNT];\r\n    biguintAssign(dst, sf);\r\n    biguintAssignIfTrue(dst, src, float(b));\r\n}",biguintDiv:"#ifndef BYTE_COUNT\r\n#define BYTE_COUNT 16\r\n#endif\r\n\r\n#ifdef GL_ES\r\nprecision highp float;\r\nprecision highp int;\r\n#endif\r\n\r\nvoid biguintRshift(float [BYTE_COUNT], inout float [BYTE_COUNT], float);\r\nfloat biguintGreaterThan(float [BYTE_COUNT], float [BYTE_COUNT]);\r\nvoid biguintLshiftByOne(inout float [BYTE_COUNT]);\r\nvoid biguintRshiftByOne(inout float [BYTE_COUNT]);\r\nvoid biguintAssign(inout float [BYTE_COUNT], float [BYTE_COUNT]);\r\nvoid biguintAssign(inout float [BYTE_COUNT], float);\r\nvoid biguintAssignIfTrue(inout float [BYTE_COUNT], float [BYTE_COUNT], float);\r\nfloat biguintGreaterThanOrEqual(float [BYTE_COUNT], float [BYTE_COUNT]);\r\nvoid biguintSub(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);\r\nvoid biguintOr(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);\r\nfloat biguintLshiftByte(float, float);\r\nfloat biguintRshiftByte(float, float);\r\nfloat biguintOrByte(float, float);\r\n\r\nvoid biguintDiv(float a[BYTE_COUNT], float b[BYTE_COUNT], inout float c[BYTE_COUNT]) {\r\n    float nonEmptyBytes, powerOfTwoBit;\r\n    for (int i = 0; i < BYTE_COUNT; i++) {\r\n        nonEmptyBytes += float(b[i] != 0.0);\r\n        powerOfTwoBit = float(i*8+0) * float(b[i] == 1.0)\r\n                      + float(i*8+1) * float(b[i] == 2.0)\r\n                      + float(i*8+2) * float(b[i] == 4.0)\r\n                      + float(i*8+3) * float(b[i] == 8.0)\r\n                      + float(i*8+4) * float(b[i] == 16.0)\r\n                      + float(i*8+5) * float(b[i] == 32.0)\r\n                      + float(i*8+6) * float(b[i] == 64.0)\r\n                      + float(i*8+7) * float(b[i] == 128.0);\r\n    }\r\n    if (nonEmptyBytes == 1.0 && powerOfTwoBit != 0.0) {\r\n        biguintRshift(a, c, powerOfTwoBit);\r\n    } else {\r\n        for (int i = 0; i < BYTE_COUNT; i++) c[i] = 0.0;\r\n        float current[BYTE_COUNT], denom[BYTE_COUNT], t1[BYTE_COUNT];\r\n        current[0] = 1.0;\r\n        biguintAssign(denom, b);\r\n        biguintAssign(t1, a);\r\n        bool overflow;\r\n        for (int i = 0; i < 8*BYTE_COUNT; i++) {\r\n            if (biguintGreaterThan(denom, a) == 1.0) {\r\n                break;\r\n            } \r\n            if (denom[BYTE_COUNT-1] >= 128.0) {\r\n                overflow = true;\r\n                break;\r\n            }\r\n            biguintLshiftByOne(current);\r\n            biguintLshiftByOne(denom);\r\n        }\r\n        if (!overflow) {\r\n            biguintRshiftByOne(denom);\r\n            biguintRshiftByOne(current);\r\n        }\r\n        for (int i = 0; i < 8*BYTE_COUNT; i++) {\r\n            float isZero = 1.0;\r\n            for (int j = 0; j < BYTE_COUNT; j++) isZero -= isZero * float(current[j] != 0.0);\r\n            if (isZero == 1.0) break;\r\n            if (biguintGreaterThanOrEqual(t1, denom) == 1.0) {\r\n                biguintSub(t1, denom, t1);\r\n                biguintOr(c, current, c);\r\n            }\r\n            biguintRshiftByOne(current);\r\n            biguintRshiftByOne(denom);\r\n        }\r\n    }\r\n}\r\n\r\nvoid biguintDiv(float a[BYTE_COUNT], float bf, inout float c[BYTE_COUNT]) {\r\n    float b[BYTE_COUNT];\r\n    biguintAssign(b, bf);\r\n    biguintDiv(a, b, c);\r\n}",biguintEquals:"#ifndef BYTE_COUNT\r\n#define BYTE_COUNT 16\r\n#endif\r\n\r\n#ifdef GL_ES\r\nprecision highp float;\r\nprecision highp int;\r\n#endif\r\n\r\nvoid biguintAssign(inout float [BYTE_COUNT], float);\r\n\r\nfloat biguintEquals(float a[BYTE_COUNT], float b[BYTE_COUNT]) {\r\n    float cmp;\r\n    for (int i = BYTE_COUNT - 1; i >= 0; i--)\r\n        cmp += float(cmp == 0.0) * float(a[i] > b[i])\r\n             - float(cmp == 0.0) * float(a[i] < b[i]);\r\n    return float(cmp == 0.0);\r\n}\r\n\r\nfloat biguintEquals(float a[BYTE_COUNT], float bf) {\r\n    float b[BYTE_COUNT];\r\n    biguintAssign(b, bf);\r\n    return biguintEquals(a, b);\r\n}",biguintGreaterThan:"#ifndef BYTE_COUNT\r\n#define BYTE_COUNT 16\r\n#endif\r\n\r\n#ifdef GL_ES\r\nprecision highp float;\r\nprecision highp int;\r\n#endif\r\n\r\nvoid biguintAssign(inout float [BYTE_COUNT], float);\r\n\r\nfloat biguintGreaterThan(float a[BYTE_COUNT], float b[BYTE_COUNT]) {\r\n    float cmp;\r\n    for (int i = BYTE_COUNT - 1; i >= 0; i--)\r\n        cmp += float(cmp == 0.0) * float(a[i] > b[i])\r\n             - float(cmp == 0.0) * float(a[i] < b[i]);\r\n    return float(cmp == 1.0);\r\n}\r\n\r\nfloat biguintGreaterThan(float a[BYTE_COUNT], float bf) {\r\n    float b[BYTE_COUNT];\r\n    biguintAssign(b, bf);\r\n    return biguintGreaterThan(a, b);\r\n}",biguintGreaterThanOrEqual:"#ifndef BYTE_COUNT\r\n#define BYTE_COUNT 16\r\n#endif\r\n\r\n#ifdef GL_ES\r\nprecision highp float;\r\nprecision highp int;\r\n#endif\r\n\r\nvoid biguintAssign(inout float [BYTE_COUNT], float);\r\n\r\nfloat biguintGreaterThanOrEqual(float a[BYTE_COUNT], float b[BYTE_COUNT]) {\r\n    float cmp;\r\n    for (int i = BYTE_COUNT - 1; i >= 0; i--)\r\n        cmp += float(cmp == 0.0) * float(a[i] > b[i])\r\n             - float(cmp == 0.0) * float(a[i] < b[i]);\r\n    return float(cmp != -1.0);\r\n}\r\n\r\nfloat biguintGreaterThanOrEqual(float a[BYTE_COUNT], float bf) {\r\n    float b[BYTE_COUNT];\r\n    biguintAssign(b, bf);\r\n    return biguintGreaterThanOrEqual(a, b);\r\n}",biguintLessThan:"#ifndef BYTE_COUNT\r\n#define BYTE_COUNT 16\r\n#endif\r\n\r\n#ifdef GL_ES\r\nprecision highp float;\r\nprecision highp int;\r\n#endif\r\n\r\nvoid biguintAssign(inout float [BYTE_COUNT], float);\r\n\r\nfloat biguintLessThan(float a[BYTE_COUNT], float b[BYTE_COUNT]) {\r\n    float cmp;\r\n    for (int i = BYTE_COUNT - 1; i >= 0; i--)\r\n        cmp += float(cmp == 0.0) * float(a[i] > b[i])\r\n             - float(cmp == 0.0) * float(a[i] < b[i]);\r\n    return float(cmp == -1.0);\r\n}\r\n\r\nfloat biguintLessThan(float a[BYTE_COUNT], float bf) {\r\n    float b[BYTE_COUNT];\r\n    biguintAssign(b, bf);\r\n    return biguintLessThan(a, b);\r\n}",biguintLessThanOrEqual:"#ifndef BYTE_COUNT\r\n#define BYTE_COUNT 16\r\n#endif\r\n\r\n#ifdef GL_ES\r\nprecision highp float;\r\nprecision highp int;\r\n#endif\r\n\r\nvoid biguintAssign(inout float [BYTE_COUNT], float);\r\n\r\nfloat biguintLessThanOrEqual(float a[BYTE_COUNT], float b[BYTE_COUNT]) {\r\n    float cmp;\r\n    for (int i = BYTE_COUNT - 1; i >= 0; i--)\r\n        cmp += float(cmp == 0.0) * float(a[i] > b[i])\r\n             - float(cmp == 0.0) * float(a[i] < b[i]);\r\n    return float(cmp != 1.0);\r\n}\r\n\r\nfloat biguintLessThanOrEqual(float a[BYTE_COUNT], float bf) {\r\n    float b[BYTE_COUNT];\r\n    biguintAssign(b, bf);\r\n    return biguintLessThanOrEqual(a, b);\r\n}",biguintLshift:"#ifndef BYTE_COUNT\r\n#define BYTE_COUNT 16\r\n#endif\r\n\r\n#ifdef GL_ES\r\nprecision highp float;\r\nprecision highp int;\r\n#endif\r\n\r\nvoid biguintLshiftWord(inout float [BYTE_COUNT], float);\r\nfloat biguintLshiftByte(float, float);\r\nvoid biguintRshiftWord(inout float [BYTE_COUNT], float);\r\nfloat biguintRshiftByte(float, float);\r\nfloat biguintOrByte(float, float);\r\nvoid biguintAssign(inout float [BYTE_COUNT], float [BYTE_COUNT]);\r\nvoid biguintAssignIfTrue(inout float [BYTE_COUNT], float [BYTE_COUNT], float);\r\n\r\nvoid biguintLshift(float a[BYTE_COUNT], inout float b[BYTE_COUNT], float count) {\r\n    count = clamp(floor(count), 0.0, float(BYTE_COUNT*8));\r\n    biguintAssign(b, a);\r\n    biguintLshiftWord(b, floor(count / 8.0));\r\n    float bits = mod(count, 8.0);\r\n    float t1[BYTE_COUNT];\r\n    biguintAssign(t1, b);\r\n    for (int i = BYTE_COUNT - 1; i > 0; i--) \r\n        t1[i] = biguintOrByte(biguintLshiftByte(t1[i], bits), \r\n                              biguintRshiftByte(t1[i-1], 8.0-bits));\r\n    t1[0] = biguintLshiftByte(t1[0], bits);\r\n    biguintAssignIfTrue(b, t1, float(bits != 0.0));\r\n}",biguintLshiftByOne:"#ifndef BYTE_COUNT\r\n#define BYTE_COUNT 16\r\n#endif\r\n\r\n#ifdef GL_ES\r\nprecision highp float;\r\nprecision highp int;\r\n#endif\r\n\r\nfloat biguintLshiftByte(float, float);\r\nfloat biguintRshiftByte(float, float);\r\nfloat biguintOrByte(float, float);\r\n\r\nvoid biguintLshiftByOne(inout float a[BYTE_COUNT]) {\r\n    for (int i = BYTE_COUNT - 1; i > 0; i--) \r\n        a[i] = biguintOrByte(biguintLshiftByte(a[i], 1.0), \r\n                             biguintRshiftByte(a[i-1], 8.0-1.0));\r\n    a[0] = biguintLshiftByte(a[0], 1.0);\r\n}",biguintLshiftByte:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nfloat biguintLshiftByte(float i, float m) {\n    return mod(floor(i * float(m == 0.0)\n                   + i * float(m == 1.0) * 2.0\n                   + i * float(m == 2.0) * 4.0\n                   + i * float(m == 3.0) * 8.0\n                   + i * float(m == 4.0) * 16.0\n                   + i * float(m == 5.0) * 32.0\n                   + i * float(m == 6.0) * 64.0\n                   + i * float(m == 7.0) * 128.0), 256.0);\n}",biguintLshiftWord:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nvoid biguintLshiftWord(inout float a[BYTE_COUNT], float count) {\n    for (int i = BYTE_COUNT - 1; i >= 0; i--)\n        a[i] = a[int(max(float(i)-count, 0.0))] \n             * float(float(i)-count >= 0.0);\n}",biguintMod:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nvoid biguintDiv(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);\nvoid biguintMul(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);\nvoid biguintSub(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);\nvoid biguintLshift(float [BYTE_COUNT], inout float [BYTE_COUNT], float);\nvoid biguintAssign(inout float [BYTE_COUNT], float);\n\nvoid biguintMod(float ia[BYTE_COUNT], float ib[BYTE_COUNT], inout float oc[BYTE_COUNT]) {\n\tfloat tc[BYTE_COUNT];\n\tbiguintDiv(ia, ib, oc);\n    biguintMul(oc, ib, tc);\n    biguintSub(ia, tc, oc);\n}\n\nvoid biguintMod(float ia[BYTE_COUNT], float ibf, inout float oc[BYTE_COUNT]) {\n    float ib[BYTE_COUNT], tc[BYTE_COUNT];\n    biguintAssign(ib, ibf);\n    biguintDiv(ia, ib, oc);\n    biguintMul(oc, ib, tc);\n    biguintSub(ia, tc, oc);\n}",biguintMul:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nvoid biguintLshift(float [BYTE_COUNT], inout float [BYTE_COUNT], float);\nvoid biguintAssign(inout float [BYTE_COUNT], float);\n\nvoid biguintMul(float a[BYTE_COUNT], float b[BYTE_COUNT], inout float c[BYTE_COUNT]) {\n    float nonEmptyBytes, powerOfTwoBit;\n    for (int i = 0; i < BYTE_COUNT; i++) {\n        nonEmptyBytes += float(b[i] != 0.0);\n        powerOfTwoBit = float(i*8+0) * float(b[i] == 1.0)\n                      + float(i*8+1) * float(b[i] == 2.0)\n                      + float(i*8+2) * float(b[i] == 4.0)\n                      + float(i*8+3) * float(b[i] == 8.0)\n                      + float(i*8+4) * float(b[i] == 16.0)\n                      + float(i*8+5) * float(b[i] == 32.0)\n                      + float(i*8+6) * float(b[i] == 64.0)\n                      + float(i*8+7) * float(b[i] == 128.0);\n    }\n    if (nonEmptyBytes == 1.0 && powerOfTwoBit != 0.0) {\n        biguintLshift(a, c, powerOfTwoBit);\n    } else {\n        float product, carry;\n        float t1[BYTE_COUNT*2];\n        for (int i = 0; i < BYTE_COUNT; i++) {\n            for (int j = 0; j < BYTE_COUNT; j++) {\n                product = a[i] * b[j] + t1[i+j];\n                carry = floor(product / 256.0);\n                t1[i+j] = product - carry * 256.0;\n                t1[i+j+1] += carry;\n            }\n        }\n        float isOver = 0.0;\n        for (int i = BYTE_COUNT; i < 2*BYTE_COUNT; i++) isOver += min(t1[i], 1.0);\n        for (int i = 0; i < BYTE_COUNT; i++) c[i] = t1[i] * (1.0 - isOver) + 255.0 * isOver;\n    }\n}\n\nvoid biguintMul(float a[BYTE_COUNT], float bf, inout float c[BYTE_COUNT]) {\n    float b[BYTE_COUNT];\n    biguintAssign(b, bf);\n    biguintMul(a, b, c);\n}",biguintOr:"#ifndef BYTE_COUNT\r\n#define BYTE_COUNT 16\r\n#endif\r\n\r\n#ifdef GL_ES\r\nprecision highp float;\r\nprecision highp int;\r\n#endif\r\n\r\n#ifndef FLOAT_GTE\r\n#define FLOAT_GTE\r\nfloat gte(float f1, float f2) {\r\n  return 1.0 - max(sign(f2 - f1), 0.0);\r\n}\r\n#endif\r\n\r\nvoid biguintOr(float a[BYTE_COUNT], float b[BYTE_COUNT], inout float c[BYTE_COUNT]) {\r\n    for (int i = 0; i < BYTE_COUNT; i++) {\r\n        float o = max(gte(a[i], 128.0), gte(b[i], 128.0)) * 128.0;\r\n        a[i] -= gte(a[i], 128.0) * 128.0;\r\n        b[i] -= gte(b[i], 128.0) * 128.0;\r\n        o += max(gte(a[i], 64.0), gte(b[i], 64.0)) * 64.0;\r\n        a[i] -= gte(a[i], 64.0) * 64.0;\r\n        b[i] -= gte(b[i], 64.0) * 64.0;\r\n        o += max(gte(a[i], 32.0), gte(b[i], 32.0)) * 32.0;\r\n        a[i] -= gte(a[i], 32.0) * 32.0;\r\n        b[i] -= gte(b[i], 32.0) * 32.0;\r\n        o += max(gte(a[i], 16.0), gte(b[i], 16.0)) * 16.0;\r\n        a[i] -= gte(a[i], 16.0) * 16.0;\r\n        b[i] -= gte(b[i], 16.0) * 16.0;\r\n        o += max(gte(a[i], 8.0), gte(b[i], 8.0)) * 8.0;\r\n        a[i] -= gte(a[i], 8.0) * 8.0;\r\n        b[i] -= gte(b[i], 8.0) * 8.0;\r\n        o += max(gte(a[i], 4.0), gte(b[i], 4.0)) * 4.0;\r\n        a[i] -= gte(a[i], 4.0) * 4.0;\r\n        b[i] -= gte(b[i], 4.0) * 4.0;\r\n        o += max(gte(a[i], 2.0), gte(b[i], 2.0)) * 2.0;\r\n        a[i] -= gte(a[i], 2.0) * 2.0;\r\n        b[i] -= gte(b[i], 2.0) * 2.0;\r\n        c[i] = o + max(gte(a[i], 1.0), gte(b[i], 1.0));\r\n    }\r\n}",biguintOrByte:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\n#ifndef FLOAT_GTE\n#define FLOAT_GTE\nfloat gte(float f1, float f2) {\n  return 1.0 - max(sign(f2 - f1), 0.0);\n}\n#endif\n\nfloat biguintOrByte(float a, float b) {\n    float o = max(gte(a, 128.0), gte(b, 128.0)) * 128.0;\n    a -= gte(a, 128.0) * 128.0;\n    b -= gte(b, 128.0) * 128.0;\n    o += max(gte(a, 64.0), gte(b, 64.0)) * 64.0;\n    a -= gte(a, 64.0) * 64.0;\n    b -= gte(b, 64.0) * 64.0;\n    o += max(gte(a, 32.0), gte(b, 32.0)) * 32.0;\n    a -= gte(a, 32.0) * 32.0;\n    b -= gte(b, 32.0) * 32.0;\n    o += max(gte(a, 16.0), gte(b, 16.0)) * 16.0;\n    a -= gte(a, 16.0) * 16.0;\n    b -= gte(b, 16.0) * 16.0;\n    o += max(gte(a, 8.0), gte(b, 8.0)) * 8.0;\n    a -= gte(a, 8.0) * 8.0;\n    b -= gte(b, 8.0) * 8.0;\n    o += max(gte(a, 4.0), gte(b, 4.0)) * 4.0;\n    a -= gte(a, 4.0) * 4.0;\n    b -= gte(b, 4.0) * 4.0;\n    o += max(gte(a, 2.0), gte(b, 2.0)) * 2.0;\n    a -= gte(a, 2.0) * 2.0;\n    b -= gte(b, 2.0) * 2.0;\n    return o + max(gte(a, 1.0), gte(b, 1.0));\n}",biguintPow:"#ifndef BYTE_COUNT\r\n#define BYTE_COUNT 16\r\n#endif\r\n\r\n#ifdef GL_ES\r\nprecision highp float;\r\nprecision highp int;\r\n#endif\r\n\r\nvoid biguintSub(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);\r\nvoid biguintMul(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);\r\nvoid biguintAssign(inout float [BYTE_COUNT], float [BYTE_COUNT]);\r\nvoid biguintAssignIfTrue(inout float [BYTE_COUNT], float [BYTE_COUNT], float);\r\n\r\nvoid biguintPow(float a[BYTE_COUNT], float bf, inout float c[BYTE_COUNT]) {\r\n    bf = max(floor(bf), 0.0);\r\n    c[0] = 1.0;\r\n    for (int i = 1; i < BYTE_COUNT; i++) c[i] = 0.0;\r\n    biguintAssignIfTrue(c, a, float(bf != 0.0));\r\n    for (int i = 0; i < 65536; i++) {\r\n        if (bf <= 1.0) break;\r\n        biguintMul(c, a, c);\r\n        bf -= 1.0;\r\n    }\r\n}",biguintRshift:"#ifndef BYTE_COUNT\r\n#define BYTE_COUNT 16\r\n#endif\r\n\r\n#ifdef GL_ES\r\nprecision highp float;\r\nprecision highp int;\r\n#endif\r\n\r\nvoid biguintLshiftWord(inout float [BYTE_COUNT], float);\r\nfloat biguintLshiftByte(float, float);\r\nvoid biguintRshiftWord(inout float [BYTE_COUNT], float);\r\nfloat biguintRshiftByte(float, float);\r\nfloat biguintOrByte(float, float);\r\nvoid biguintAssign(inout float [BYTE_COUNT], float [BYTE_COUNT]);\r\nvoid biguintAssignIfTrue(inout float [BYTE_COUNT], float [BYTE_COUNT], float);\r\n\r\nvoid biguintRshift(float a[BYTE_COUNT], inout float b[BYTE_COUNT], float count) {\r\n    count = clamp(floor(count), 0.0, float(BYTE_COUNT*8));\r\n    biguintAssign(b, a);\r\n    biguintRshiftWord(b, floor(count / 8.0));\r\n    float bits = mod(count, 8.0);\r\n    float t1[BYTE_COUNT];\r\n    biguintAssign(t1, b);\r\n    for (int i = 0; i < BYTE_COUNT - 1; i++)\r\n        t1[i] = biguintOrByte(biguintRshiftByte(t1[i], bits),\r\n                              biguintLshiftByte(t1[i+1], 8.0-bits));\r\n    t1[BYTE_COUNT-1] = biguintRshiftByte(t1[BYTE_COUNT-1], bits);\r\n    biguintAssignIfTrue(b, t1, float(bits != 0.0));\r\n}",biguintRshiftByOne:"#ifndef BYTE_COUNT\r\n#define BYTE_COUNT 16\r\n#endif\r\n\r\n#ifdef GL_ES\r\nprecision highp float;\r\nprecision highp int;\r\n#endif\r\n\r\nfloat biguintLshiftByte(float, float);\r\nfloat biguintRshiftByte(float, float);\r\nfloat biguintOrByte(float, float);\r\n\r\nvoid biguintRshiftByOne(inout float a[BYTE_COUNT]) {\r\n    for (int i = 0; i < BYTE_COUNT - 1; i++)\r\n        a[i] = biguintOrByte(biguintRshiftByte(a[i], 1.0),\r\n                             biguintLshiftByte(a[i+1], 8.0-1.0));\r\n    a[BYTE_COUNT-1] = biguintRshiftByte(a[BYTE_COUNT-1], 1.0);\r\n}",biguintRshiftByte:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nfloat biguintRshiftByte(float i, float m) {\n    return floor(i * float(m == 0.0)\n               + i * float(m == 1.0) / 2.0\n               + i * float(m == 2.0) / 4.0\n               + i * float(m == 3.0) / 8.0\n               + i * float(m == 4.0) / 16.0\n               + i * float(m == 5.0) / 32.0\n               + i * float(m == 6.0) / 64.0\n               + i * float(m == 7.0) / 128.0);\n}",biguintRshiftWord:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\n#ifndef FLOAT_LT\n#define FLOAT_LT\nfloat lt(float f1, float f2) {\n  return max(sign(f2 - f1), 0.0);\n}\n#endif\n\nvoid biguintRshiftWord(inout float a[BYTE_COUNT], float count) {\n    for (int i = 0; i < BYTE_COUNT; i++) \n        a[i] = a[int(min(float(i)+count, float(BYTE_COUNT) - 1.0))]\n             * lt(float(i)+count, float(BYTE_COUNT));\n}",biguintSqrt:"#ifndef BYTE_COUNT\r\n#define BYTE_COUNT 16\r\n#endif\r\n\r\n#ifdef GL_ES\r\nprecision highp float;\r\nprecision highp int;\r\n#endif\r\n\r\nvoid biguintRshift(float [BYTE_COUNT], inout float [BYTE_COUNT], float);\r\nvoid biguintAdd(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);\r\nvoid biguintAdd(float [BYTE_COUNT], float, inout float [BYTE_COUNT]);\r\nfloat biguintLessThan(float [BYTE_COUNT], float [BYTE_COUNT]);\r\nfloat biguintLessThanOrEqual(float [BYTE_COUNT], float [BYTE_COUNT]);\r\nfloat biguintGreaterThan(float [BYTE_COUNT], float [BYTE_COUNT]);\r\nfloat biguintGreaterThanOrEqual(float [BYTE_COUNT], float [BYTE_COUNT]);\r\nvoid biguintMul(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);\r\nvoid biguintSub(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);\r\nvoid biguintSub(float [BYTE_COUNT], float, inout float [BYTE_COUNT]);\r\nvoid biguintAssign(inout float [BYTE_COUNT], float [BYTE_COUNT]);\r\nvoid biguintAssignIfTrue(inout float [BYTE_COUNT], float [BYTE_COUNT], float);\r\nvoid biguintRshiftByOne(inout float [BYTE_COUNT]);\r\n\r\nvoid biguintSqrt(inout float a[BYTE_COUNT]) {\r\n    float low[BYTE_COUNT], high[BYTE_COUNT], mid[BYTE_COUNT], t1[BYTE_COUNT];\r\n    biguintAssign(high, a);\r\n    biguintRshift(high, mid, 1.0);\r\n    biguintAdd(mid, 1.0, mid);\r\n    for (int i = 0; i < BYTE_COUNT * 8; i++) {\r\n        if (biguintLessThanOrEqual(high, low) == 1.0) break;\r\n        biguintMul(mid, mid, t1);\r\n        float isGreaterThan = biguintGreaterThan(t1, a);\r\n        biguintAssign(t1, mid);\r\n        biguintSub(t1, 1.0, t1);\r\n        biguintAssignIfTrue(high, t1, isGreaterThan);\r\n\t\tbiguintAssignIfTrue(low, mid, 1.0 - isGreaterThan);\r\n\t\tbiguintSub(high, low, mid);\r\n        biguintRshiftByOne(mid);\r\n        biguintAdd(low, mid, mid);\r\n        biguintAdd(mid, 1.0, mid);\r\n    }\r\n    biguintAssign(a, low);\r\n}\r\n\r\nvoid biguintSqrt(float a[BYTE_COUNT], inout float b[BYTE_COUNT]) {\r\n    biguintAssign(b, a);\r\n    biguintSqrt(b);\r\n}",biguintSub:"#ifndef BYTE_COUNT\r\n#define BYTE_COUNT 16\r\n#endif\r\n\r\n#ifdef GL_ES\r\nprecision highp float;\r\nprecision highp int;\r\n#endif\r\n\r\n#ifndef FLOAT_LTZ\r\n#define FLOAT_LTZ\r\nfloat ltz(float f) {\r\n  return abs(min(sign(f), 0.0));\r\n}\r\n#endif\r\n\r\nvoid biguintAssign(inout float [BYTE_COUNT], float);\r\n\r\nvoid biguintSub(float a[BYTE_COUNT], float b[BYTE_COUNT], inout float c[BYTE_COUNT]) {\r\n    float borrow, tmp;\r\n    for (int i = 0; i < BYTE_COUNT; i++) {\r\n        tmp = a[i] - b[i] - borrow;\r\n        borrow = ltz(tmp);\r\n        c[i] = mod(tmp, 256.0); \r\n    }\r\n}\r\n\r\nvoid biguintSub(float a[BYTE_COUNT], float bf, inout float c[BYTE_COUNT]) {\r\n    float b[BYTE_COUNT];\r\n    biguintAssign(b, bf);\r\n    biguintSub(a, b, c);\r\n}",biguintXor:"#ifndef BYTE_COUNT\r\n#define BYTE_COUNT 16\r\n#endif\r\n\r\n#ifdef GL_ES\r\nprecision highp float;\r\nprecision highp int;\r\n#endif\r\n\r\n#ifndef FLOAT_NE\r\n#define FLOAT_NE\r\nfloat ne(float f1, float f2) {\r\n  return 1.0 - float(f1 == f2);\r\n}\r\n#endif\r\n\r\n#ifndef FLOAT_GTE\r\n#define FLOAT_GTE\r\nfloat gte(float f1, float f2) {\r\n  return 1.0 - max(sign(f2 - f1), 0.0);\r\n}\r\n#endif\r\n\r\nvoid biguintXor(float a[BYTE_COUNT], float b[BYTE_COUNT], inout float c[BYTE_COUNT]) {\r\n    for (int i = 0; i < BYTE_COUNT; i++) {\r\n        float o = ne(gte(a[i], 128.0), gte(b[i], 128.0)) * 128.0;\r\n        a[i] -= gte(a[i], 128.0) * 128.0;\r\n        b[i] -= gte(b[i], 128.0) * 128.0;\r\n        o += ne(gte(a[i], 64.0), gte(b[i], 64.0)) * 64.0;\r\n        a[i] -= gte(a[i], 64.0) * 64.0;\r\n        b[i] -= gte(b[i], 64.0) * 64.0;\r\n        o += ne(gte(a[i], 32.0), gte(b[i], 32.0)) * 32.0;\r\n        a[i] -= gte(a[i], 32.0) * 32.0;\r\n        b[i] -= gte(b[i], 32.0) * 32.0;\r\n        o += ne(gte(a[i], 16.0), gte(b[i], 16.0)) * 16.0;\r\n        a[i] -= gte(a[i], 16.0) * 16.0;\r\n        b[i] -= gte(b[i], 16.0) * 16.0;\r\n        o += ne(gte(a[i], 8.0), gte(b[i], 8.0)) * 8.0;\r\n        a[i] -= gte(a[i], 8.0) * 8.0;\r\n        b[i] -= gte(b[i], 8.0) * 8.0;\r\n        o += ne(gte(a[i], 4.0), gte(b[i], 4.0)) * 4.0;\r\n        a[i] -= gte(a[i], 4.0) * 4.0;\r\n        b[i] -= gte(b[i], 4.0) * 4.0;\r\n        o += ne(gte(a[i], 2.0), gte(b[i], 2.0)) * 2.0;\r\n        a[i] -= gte(a[i], 2.0) * 2.0;\r\n        b[i] -= gte(b[i], 2.0) * 2.0;\r\n        c[i] = o + ne(gte(a[i], 1.0), gte(b[i], 1.0));\r\n    }\r\n}"},Object.keys(i.functionStrings).forEach(n=>{const t=i.functionStrings;t[n]=t[n].replace(/\r+/gm,"").replace(/\t/g,"    ").replace(/\n{3,}/g,"\n\n")}),i.untouchedFunctionStrings=Object.assign({},i.functionStrings),i.declarations={biguintAdd:{prepend:["#ifndef BIG_UINT_ADD","#define BIG_UINT_ADD"].join("\n"),declarations:["void biguintAdd(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);","void biguintAdd(float [BYTE_COUNT], float, inout float [BYTE_COUNT]);"],append:"#endif"},biguintAnd:{prepend:["#ifndef BIG_UINT_AND","#define BIG_UINT_AND"].join("\n"),declarations:["void biguintAnd(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);"],append:"#endif"},biguintAssign:{prepend:["#ifndef BIG_UINT_ASSIGN","#define BIG_UINT_ASSIGN"].join("\n"),declarations:["void biguintAssign(inout float [BYTE_COUNT], float [BYTE_COUNT]);","void biguintAssign(inout float [BYTE_COUNT], float);"],append:"#endif"},biguintAssignIfTrue:{prepend:["#ifndef BIG_UINT_ASSIGN_IF_TRUE","#define BIG_UINT_ASSIGN_IF_TRUE"].join("\n"),declarations:["void biguintAssignIfTrue(inout float [BYTE_COUNT], float [BYTE_COUNT], float);","void biguintAssignIfTrue(inout float [BYTE_COUNT], float [BYTE_COUNT], bool);","void biguintAssignIfTrue(inout float [BYTE_COUNT], float, float);","void biguintAssignIfTrue(inout float [BYTE_COUNT], float, bool);"],append:"#endif"},biguintDiv:{prepend:["#ifndef BIG_UINT_DIV","#define BIG_UINT_DIV"].join("\n"),declarations:["void biguintDiv(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);","void biguintDiv(float [BYTE_COUNT], float, inout float [BYTE_COUNT]);"],append:"#endif"},biguintEquals:{prepend:["#ifndef BIG_UINT_EQUALS","#define BIG_UINT_EQUALS"].join("\n"),declarations:["float biguintEquals(float [BYTE_COUNT], float [BYTE_COUNT]);","float biguintEquals(float [BYTE_COUNT], float);"],append:"#endif"},biguintGreaterThan:{prepend:["#ifndef BIG_UINT_GREATER_THAN","#define BIG_UINT_GREATER_THAN"].join("\n"),declarations:["float biguintGreaterThan(float [BYTE_COUNT], float [BYTE_COUNT]);","float biguintGreaterThan(float [BYTE_COUNT], float);"],append:"#endif"},biguintGreaterThanOrEqual:{prepend:["#ifndef BIG_UINT_GREATER_THAN_OR_EQUAL","#define BIG_UINT_GREATER_THAN_OR_EQUAL"].join("\n"),declarations:["float biguintGreaterThanOrEqual(float [BYTE_COUNT], float [BYTE_COUNT]);","float biguintGreaterThanOrEqual(float [BYTE_COUNT], float);"],append:"#endif"},biguintLessThan:{prepend:["#ifndef BIG_UINT_LESS_THAN","#define BIG_UINT_LESS_THAN"].join("\n"),declarations:["float biguintLessThan(float [BYTE_COUNT], float [BYTE_COUNT]);","float biguintLessThan(float [BYTE_COUNT], float);"],append:"#endif"},biguintLessThanOrEqual:{prepend:["#ifndef BIG_UINT_LESS_THAN_OR_EQUAL","#define BIG_UINT_LESS_THAN_OR_EQUAL"].join("\n"),declarations:["float biguintLessThanOrEqual(float [BYTE_COUNT], float [BYTE_COUNT]);","float biguintLessThanOrEqual(float [BYTE_COUNT], float);"],append:"#endif"},biguintLshift:{prepend:["#ifndef BIG_UINT_LSHIFT","#define BIG_UINT_LSHIFT"].join("\n"),declarations:["void biguintLshift(float [BYTE_COUNT], inout float [BYTE_COUNT], float);"],append:"#endif"},biguintLshiftByOne:{prepend:["#ifndef BIG_UINT_LSHIFT_BY_ONE","#define BIG_UINT_LSHIFT_BY_ONE"].join("\n"),declarations:["void biguintLshiftByOne(inout float [BYTE_COUNT]);"],append:"#endif"},biguintLshiftByte:{prepend:["#ifndef BIG_UINT_LSHIFT_BYTE","#define BIG_UINT_LSHIFT_BYTE"].join("\n"),declarations:["float biguintLshiftByte(float, float);"],append:"#endif"},biguintLshiftWord:{prepend:["#ifndef BIG_UINT_LSHIFT_WORD","#define BIG_UINT_LSHIFT_WORD"].join("\n"),declarations:["void biguintLshiftWord(inout float [BYTE_COUNT], float);"],append:"#endif"},biguintMod:{prepend:["#ifndef BIG_UINT_MOD","#define BIG_UINT_MOD"].join("\n"),declarations:["void biguintMod(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);","void biguintMod(float [BYTE_COUNT], float, inout float [BYTE_COUNT]);"],append:"#endif"},biguintMul:{prepend:["#ifndef BIG_UINT_MUL","#define BIG_UINT_MUL"].join("\n"),declarations:["void biguintMul(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);","void biguintMul(float [BYTE_COUNT], float, inout float [BYTE_COUNT]);"],append:"#endif"},biguintOr:{prepend:["#ifndef BIG_UINT_OR","#define BIG_UINT_OR"].join("\n"),declarations:["void biguintOr(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);"],append:"#endif"},biguintOrByte:{prepend:["#ifndef BIG_UINT_OR_BYTE","#define BIG_UINT_OR_BYTE"].join("\n"),declarations:["float biguintOrByte(float, float);"],append:"#endif"},biguintPow:{prepend:["#ifndef BIG_UINT_POW","#define BIG_UINT_POW"].join("\n"),declarations:["void biguintPow(float [BYTE_COUNT], float, inout float [BYTE_COUNT]);"],append:"#endif"},biguintRshift:{prepend:["#ifndef BIG_UINT_RSHIFT","#define BIG_UINT_RSHIFT"].join("\n"),declarations:["void biguintRshift(float [BYTE_COUNT], inout float [BYTE_COUNT], float);"],append:"#endif"},biguintRshiftByOne:{prepend:["#ifndef BIG_UINT_RSHIFT_BY_ONE","#define BIG_UINT_RSHIFT_BY_ONE"].join("\n"),declarations:["void biguintRshiftByOne(inout float [BYTE_COUNT]);"],append:"#endif"},biguintRshiftByte:{prepend:["#ifndef BIG_UINT_RSHIFT_BYTE","#define BIG_UINT_RSHIFT_BYTE"].join("\n"),declarations:["float biguintRshiftByte(float, float);"],append:"#endif"},biguintRshiftWord:{prepend:["#ifndef BIG_UINT_RSHIFT_WORD","#define BIG_UINT_RSHIFT_WORD"].join("\n"),declarations:["void biguintRshiftWord(inout float [BYTE_COUNT], float);"],append:"#endif"},biguintSqrt:{prepend:["#ifndef BIG_UINT_SQRT","#define BIG_UINT_SQRT"].join("\n"),declarations:["void biguintSqrt(float [BYTE_COUNT], inout float [BYTE_COUNT]);"],append:"#endif"},biguintSub:{prepend:["#ifndef BIG_UINT_SUB","#define BIG_UINT_SUB"].join("\n"),declarations:["void biguintSub(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);","void biguintSub(float [BYTE_COUNT], float, inout float [BYTE_COUNT]);"],append:"#endif"},biguintXor:{prepend:["#ifndef BIG_UINT_XOR","#define BIG_UINT_XOR"].join("\n"),declarations:["void biguintXor(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);"],append:"#endif"}};const r=[["#ifndef BYTE_COUNT","#define BYTE_COUNT 16","#endif","","#ifdef GL_ES","precision highp float;","precision highp int;","#endif"].join("\n")];Object.assign(i.functionStrings,o.renderDefinitions(i.functionStrings,i.declarations,r)),i.expandDefinitions=function(n){return n=o.replaceDefinitions(n,i.functionStrings,i.declarations),o.removeStutters(n,r).replace(/\n{3,}/g,"\n\n")}}]);