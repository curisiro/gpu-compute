window.browserbench=function(n){var t={};function i(e){if(t[e])return t[e].exports;var o=t[e]={i:e,l:!1,exports:{}};return n[e].call(o.exports,o,o.exports,i),o.l=!0,o.exports}return i.m=n,i.c=t,i.d=function(n,t,e){i.o(n,t)||Object.defineProperty(n,t,{enumerable:!0,get:e})},i.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},i.t=function(n,t){if(1&t&&(n=i(n)),8&t)return n;if(4&t&&"object"==typeof n&&n&&n.__esModule)return n;var e=Object.create(null);if(i.r(e),Object.defineProperty(e,"default",{enumerable:!0,value:n}),2&t&&"string"!=typeof n)for(var o in n)i.d(e,o,function(t){return n[t]}.bind(null,o));return e},i.n=function(n){var t=n&&n.__esModule?function(){return n.default}:function(){return n};return i.d(t,"a",t),t},i.o=function(n,t){return Object.prototype.hasOwnProperty.call(n,t)},i.p="",i(i.s=13)}([function(n,t,i){"use strict";var e=this&&this.__createBinding||(Object.create?function(n,t,i,e){void 0===e&&(e=i),Object.defineProperty(n,e,{enumerable:!0,get:function(){return t[i]}})}:function(n,t,i,e){void 0===e&&(e=i),n[e]=t[i]}),o=this&&this.__setModuleDefault||(Object.create?function(n,t){Object.defineProperty(n,"default",{enumerable:!0,value:t})}:function(n,t){n.default=t}),a=this&&this.__importStar||function(n){if(n&&n.__esModule)return n;var t={};if(null!=n)for(var i in n)Object.hasOwnProperty.call(n,i)&&e(t,n,i);return o(t,n),t};Object.defineProperty(t,"__esModule",{value:!0}),t.functionStrings=t.rendered=t.replaceDependencies=t.commonStutters=void 0;const f=a(i(5)),r=a(i(6)),l=a(i(3)),T=i(2);t.commonStutters=[/^[ \t]*#ifndef[ \t]+BYTE_COUNT[ \t]*\n[ \t]*#define[ \t]+BYTE_COUNT[ \t]+16[ \t]*\n[ \t]*#endif[ \t]*/gm,/^[ \t]*#ifdef[ \t]+GL_ES[ \t]*\n[ \t]*precision[ \t]+highp[ \t]+float;[ \t]*\n[ \t]*precision[ \t]+highp[ \t]+int;[ \t]*\n[ \t]*#endif[ \t]*/gm],t.replaceDependencies=function(n){return T.replace(n,T.merge(f.dependencies,r.dependencies,l.dependencies),t.commonStutters)},t.rendered=T.render(f.dependencies,t.commonStutters),t.functionStrings={eq:t.rendered.eq,gt:t.rendered.gt,gte:t.rendered.gte,int16FromVec2:t.rendered.int16FromVec2,int16ToVec2:t.rendered.int16ToVec2,lt:t.rendered.lt,lte:t.rendered.lte,neq:t.rendered.neq,packBooleans:t.rendered.packBooleans,round:t.rendered.round,uint16FromVec2:t.rendered.uint16FromVec2,uint16ToVec2:t.rendered.uint16ToVec2,unpackBooleans:t.rendered.unpackBooleans,bigintAbs:r.rendered.bigintAbs,bigintAdd:r.rendered.bigintAdd,bigintAnd:r.rendered.bigintAnd,bigintApplyTwosComplement:r.rendered.bigintApplyTwosComplement,bigintAssign:r.rendered.bigintAssign,bigintAssignIfTrue:r.rendered.bigintAssignIfTrue,bigintDiv:r.rendered.bigintDiv,bigintEquals:r.rendered.bigintEquals,bigintGreaterThan:r.rendered.bigintGreaterThan,bigintGreaterThanOrEqual:r.rendered.bigintGreaterThanOrEqual,bigintLessThan:r.rendered.bigintLessThan,bigintLessThanOrEqual:r.rendered.bigintLessThanOrEqual,bigintLshift:r.rendered.bigintLshift,bigintLshiftByOne:r.rendered.bigintLshiftByOne,bigintMul:r.rendered.bigintMul,bigintOr:r.rendered.bigintOr,bigintRemoveTwosComplement:r.rendered.bigintRemoveTwosComplement,bigintRshift:r.rendered.bigintRshift,bigintRshiftByOne:r.rendered.bigintRshiftByOne,bigintSub:r.rendered.bigintSub,bigintXor:r.rendered.bigintXor,biguintAdd:l.rendered.biguintAdd,biguintAnd:l.rendered.biguintAnd,biguintAssign:l.rendered.biguintAssign,biguintAssignIfTrue:l.rendered.biguintAssignIfTrue,biguintDiv:l.rendered.biguintDiv,biguintEquals:l.rendered.biguintEquals,biguintGreaterThan:l.rendered.biguintGreaterThan,biguintGreaterThanOrEqual:l.rendered.biguintGreaterThanOrEqual,biguintLessThan:l.rendered.biguintLessThan,biguintLessThanOrEqual:l.rendered.biguintLessThanOrEqual,biguintLshift:l.rendered.biguintLshift,biguintLshiftByOne:l.rendered.biguintLshiftByOne,biguintLshiftByte:l.rendered.biguintLshiftByte,biguintLshiftWord:l.rendered.biguintLshiftWord,biguintMod:l.rendered.biguintMod,biguintMul:l.rendered.biguintMul,biguintOr:l.rendered.biguintOr,biguintOrByte:l.rendered.biguintOrByte,biguintPow:l.rendered.biguintPow,biguintRshift:l.rendered.biguintRshift,biguintRshiftByOne:l.rendered.biguintRshiftByOne,biguintRshiftByte:l.rendered.biguintRshiftByte,biguintRshiftWord:l.rendered.biguintRshiftWord,biguintSqrt:l.rendered.biguintSqrt,biguintSub:l.rendered.biguintSub,biguintXor:l.rendered.biguintXor}},function(n,t,i){"use strict";var e;function o(){if(!e)try{const n=document.createElement("canvas");if(!n)throw new Error("unable to create canvas");const t=n.getContext("webgl2");if(t&&"undefined"!=typeof WebGL2RenderingContext)console.debug("your browser supports WebGL2"),e=t;else{console.debug("your browser doesn't support WebGL2");const t=n.getContext("webgl");if(!t)throw new Error("unable to get context");e=t}}catch(n){throw new Error("unable to get WebGL context from canvas")}return e}Object.defineProperty(t,"__esModule",{value:!0}),t.getMaxRenderBufferSize=t.isWebGL2=t.setWebGLContext=t.getWebGLContext=void 0,t.getWebGLContext=o,t.setWebGLContext=function(n){return e=n||o()},t.isWebGL2=function(){return"undefined"!=typeof WebGL2RenderingContext&&o()instanceof WebGL2RenderingContext};var a=0;t.getMaxRenderBufferSize=function(){if(!a){const n=o();a=n.getParameter(n.MAX_RENDERBUFFER_SIZE)}return a}},function(n,t,i){"use strict";function e(n,t){let i=`^[ \t]*${t.returns}[ \t]+${n}\\(`;for(let n of t.parameters){const t=n.qualifier?n.qualifier:"in";i+="[ \t]*"+("in"===t?"(?:in)?":t),i+=`[ \t]*${n.type}[ \t]*w*`,i+=n.arrayLength?`\\[${n.arrayLength}\\]`:"",i+="[ \t]*,"}return new RegExp(i.slice(0,-1)+"\\);","gm")}function o(n,t){let i=0;const o=[],a=(n,f)=>{for(let[o,r]of Object.entries(t))for(let t of r.signatures)if(f.match(e(o,t))){if(i++>1e6)throw new Error(`dependency loop: ${n} ${o}`);a(o,r.source)}n&&!o.includes(n)&&o.push(n)};return a(null,n),o}function a(n,t){for(let[i,o]of Object.entries(t))for(let t of o.signatures){const o=e(i,t);n=n.replace(o,"")}return n}function f(n){return n.replace(/[\w]([A-Z])/g,n=>`${n[0]}_${n[1]}`).toLowerCase()}function r(n,t){const i=f(t).toUpperCase();return`#ifndef ${i}\n#define ${i}\n\n${n}\n\n#endif\n`}function l(n,t,i){let e="";for(let n of t){e+=r(a(i[n].source,i),n)+"\n"}return e+n}function T(n){return new RegExp(n.replace(/[.*+\-?^${}()|[\]\\]/g,"\\$&"),"gm")}function s(n,t){for(let i of t){let t=0;"string"==typeof i&&(i=T(i)),n=n.replace(i,n=>0==t++?n:"")}return n}function u(n){const t=(i=n,JSON.parse(JSON.stringify(i)));var i;for(let n of Object.values(t))n.source=n.source.replace(/\r+/gm,"").replace(/\t/g,"    ").replace(/\n{3,}/g,"\n\n");return t}function g(n,t){const i={};n=u(n);for(let[e,f]of Object.entries(n)){const T=o(f.source,n);i[e]=a(f.source,n),i[e]=s(i[e],t||[]),i[e]=r(i[e],e),i[e]=l(i[e],T,n),i[e]=i[e].replace(/\n{3,}/g,"\n\n")}return i}function d(n){const t={returns:n.split(/\s+/gm)[0],parameters:[]};n=n.split("(")[1].split(")")[0];for(let i of n.split(/,\s+/gm)){const n={},e=i.split(/\s+/gm);if(["in","out","inout"].includes(e[0])&&(n.qualifier=e[0],e.shift()),n.type=e[0],!n.type)throw new Error("unable to determine parameter type");if(e.shift(),e[0]&&e[0].startsWith("[")&&e[0].endsWith("]")){const t=e[0].slice(1).slice(0,-1);n.arrayLength=Number(t)?Number(t):t}t.parameters.push(n)}if(!t.returns)throw new Error("unable to parse return type");return t}Object.defineProperty(t,"__esModule",{value:!0}),t.getDependencies=t.replace=t.merge=t.render=t.camelToSnake=void 0,t.camelToSnake=f,t.render=g,t.merge=function(...n){const t={};for(let i of n)Object.assign(t,i);return t},t.replace=function(n,t,i){i=i||[];const o=g(t=u(t),i);for(let[i,a]of Object.entries(t))for(let t of a.signatures){const a=e(i,t);n=n.replace(a,o[i])}return s(n,[...Object.values(o),...i]).replace(/\n{3,}/g,"\n\n")},t.getDependencies=function(n){const t={};for(let[i,e]of Object.entries(n))t[i]={source:e.source,signatures:Array.from(e.declarations,n=>d(n))};return u(t)}},function(n,t,i){"use strict";var e=this&&this.__createBinding||(Object.create?function(n,t,i,e){void 0===e&&(e=i),Object.defineProperty(n,e,{enumerable:!0,get:function(){return t[i]}})}:function(n,t,i,e){void 0===e&&(e=i),n[e]=t[i]}),o=this&&this.__setModuleDefault||(Object.create?function(n,t){Object.defineProperty(n,"default",{enumerable:!0,value:t})}:function(n,t){n.default=t}),a=this&&this.__importStar||function(n){if(n&&n.__esModule)return n;var t={};if(null!=n)for(var i in n)Object.hasOwnProperty.call(n,i)&&e(t,n,i);return o(t,n),t};Object.defineProperty(t,"__esModule",{value:!0}),t.rendered=t.dependencies=t.encodeUnsignedBytes=t.decodeUnsignedBytes=void 0;const f=a(i(5)),r=i(9),l=i(0),T=i(2);t.decodeUnsignedBytes=function(n,t){return t&&n.reverse(),BigInt("0x"+r.bytesToHex(n))},t.encodeUnsignedBytes=function(n,t){n<BigInt(0)&&(n=BigInt(0));const i=r.hexToBytes(n.toString(16));return t&&i.reverse(),i},t.dependencies=T.merge(f.dependencies,T.getDependencies({biguintAdd:{source:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nvoid biguintAssign(inout float [BYTE_COUNT], float);\n\nvoid biguintAdd(float a[BYTE_COUNT], float b[BYTE_COUNT], inout float c[BYTE_COUNT]) {\n    float carry, tmp;\n    for (int i = 0; i < BYTE_COUNT; i++) {\n        tmp = a[i] + b[i] + carry;\n        carry = floor(tmp / 256.0);\n        c[i] = mod(tmp, 256.0);\n    }\n}\n\nvoid biguintAdd(float a[BYTE_COUNT], float bf, inout float c[BYTE_COUNT]) {\n    float b[BYTE_COUNT];\n    biguintAssign(b, bf);\n    biguintAdd(a, b, c);\n}",declarations:["void biguintAdd(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);","void biguintAdd(float [BYTE_COUNT], float, inout float [BYTE_COUNT]);"]},biguintAnd:{source:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nfloat gte(float, float);\n\nvoid biguintAnd(float a[BYTE_COUNT], float b[BYTE_COUNT], inout float c[BYTE_COUNT]) {\n    for (int i = 0; i < BYTE_COUNT; i++) {\n        float o = gte(a[i], 128.0) * gte(b[i], 128.0) * 128.0;\n        a[i] -= gte(a[i], 128.0) * 128.0;\n        b[i] -= gte(b[i], 128.0) * 128.0;\n        o += gte(a[i], 64.0) * gte(b[i], 64.0) * 64.0;\n        a[i] -= gte(a[i], 64.0) * 64.0;\n        b[i] -= gte(b[i], 64.0) * 64.0;\n        o += gte(a[i], 32.0) * gte(b[i], 32.0) * 32.0;\n        a[i] -= gte(a[i], 32.0) * 32.0;\n        b[i] -= gte(b[i], 32.0) * 32.0;\n        o += gte(a[i], 16.0) * gte(b[i], 16.0) * 16.0;\n        a[i] -= gte(a[i], 16.0) * 16.0;\n        b[i] -= gte(b[i], 16.0) * 16.0;\n        o += gte(a[i], 8.0) * gte(b[i], 8.0) * 8.0;\n        a[i] -= gte(a[i], 8.0) * 8.0;\n        b[i] -= gte(b[i], 8.0) * 8.0;\n        o += gte(a[i], 4.0) * gte(b[i], 4.0) * 4.0;\n        a[i] -= gte(a[i], 4.0) * 4.0;\n        b[i] -= gte(b[i], 4.0) * 4.0;\n        o += gte(a[i], 2.0) * gte(b[i], 2.0) * 2.0;\n        a[i] -= gte(a[i], 2.0) * 2.0;\n        b[i] -= gte(b[i], 2.0) * 2.0;\n        c[i] = o + gte(a[i], 1.0) * gte(b[i], 1.0);\n    }\n}",declarations:["void biguintAnd(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);"]},biguintAssign:{source:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nvoid biguintAssign(inout float dst[BYTE_COUNT], float src[BYTE_COUNT]) {\n    for (int i = 0; i < BYTE_COUNT; i++) dst[i] = src[i];\n}\n\nvoid biguintAssign(inout float dst[BYTE_COUNT], float f) {\n    f = clamp(floor(f), 0.0, 65535.0);\n    dst[0] = mod(f, 256.0);\n    dst[1] = floor(f / 256.0);\n    for (int i = 2; i < BYTE_COUNT; i++) dst[i] = 0.0;\n}",declarations:["void biguintAssign(inout float [BYTE_COUNT], float [BYTE_COUNT]);","void biguintAssign(inout float [BYTE_COUNT], float);"]},biguintAssignIfTrue:{source:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nfloat eq(float, float);\nfloat neq(float, float);\n\nvoid biguintAssign(inout float [BYTE_COUNT], float);\n\nvoid biguintAssignIfTrue(inout float dst[BYTE_COUNT], float src[BYTE_COUNT], float f) {\n    for (int i = 0; i < BYTE_COUNT; i++) \n        dst[i] = src[i] * neq(f, 0.0)\n               + dst[i] * eq(f, 0.0);\n}\n\nvoid biguintAssignIfTrue(inout float dst[BYTE_COUNT], float src[BYTE_COUNT], bool b) {\n    biguintAssignIfTrue(dst, src, float(b));\n}\n\nvoid biguintAssignIfTrue(inout float dst[BYTE_COUNT], float sf, float f) {\n    float src[BYTE_COUNT];\n    biguintAssign(dst, sf);\n    biguintAssignIfTrue(dst, src, f);\n}\n\nvoid biguintAssignIfTrue(inout float dst[BYTE_COUNT], float sf, bool b) {\n    float src[BYTE_COUNT];\n    biguintAssign(dst, sf);\n    biguintAssignIfTrue(dst, src, float(b));\n}",declarations:["void biguintAssignIfTrue(inout float [BYTE_COUNT], float [BYTE_COUNT], float);","void biguintAssignIfTrue(inout float [BYTE_COUNT], float [BYTE_COUNT], bool);","void biguintAssignIfTrue(inout float [BYTE_COUNT], float, float);","void biguintAssignIfTrue(inout float [BYTE_COUNT], float, bool);"]},biguintDiv:{source:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nfloat neq(float, float);\n\nvoid biguintRshift(float [BYTE_COUNT], inout float [BYTE_COUNT], float);\nfloat biguintGreaterThan(float [BYTE_COUNT], float [BYTE_COUNT]);\nvoid biguintLshiftByOne(inout float [BYTE_COUNT]);\nvoid biguintRshiftByOne(inout float [BYTE_COUNT]);\nvoid biguintAssign(inout float [BYTE_COUNT], float [BYTE_COUNT]);\nvoid biguintAssign(inout float [BYTE_COUNT], float);\nvoid biguintAssignIfTrue(inout float [BYTE_COUNT], float [BYTE_COUNT], float);\nfloat biguintGreaterThanOrEqual(float [BYTE_COUNT], float [BYTE_COUNT]);\nvoid biguintSub(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);\nvoid biguintOr(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);\nfloat biguintLshiftByte(float, float);\nfloat biguintRshiftByte(float, float);\nfloat biguintOrByte(float, float);\n\nvoid biguintDiv(float a[BYTE_COUNT], float b[BYTE_COUNT], inout float c[BYTE_COUNT]) {\n    float nonEmptyBytes, powerOfTwoBit;\n    for (int i = 0; i < BYTE_COUNT; i++) {\n        nonEmptyBytes += float(b[i] != 0.0);\n        powerOfTwoBit = float(i*8+0) * float(b[i] == 1.0)\n                      + float(i*8+1) * float(b[i] == 2.0)\n                      + float(i*8+2) * float(b[i] == 4.0)\n                      + float(i*8+3) * float(b[i] == 8.0)\n                      + float(i*8+4) * float(b[i] == 16.0)\n                      + float(i*8+5) * float(b[i] == 32.0)\n                      + float(i*8+6) * float(b[i] == 64.0)\n                      + float(i*8+7) * float(b[i] == 128.0);\n    }\n    if (nonEmptyBytes == 1.0 && powerOfTwoBit != 0.0) {\n        biguintRshift(a, c, powerOfTwoBit);\n    } else {\n        for (int i = 0; i < BYTE_COUNT; i++) c[i] = 0.0;\n        float current[BYTE_COUNT], denom[BYTE_COUNT], t1[BYTE_COUNT];\n        current[0] = 1.0;\n        biguintAssign(denom, b);\n        biguintAssign(t1, a);\n        bool overflow;\n        for (int i = 0; i < 8*BYTE_COUNT; i++) {\n            if (biguintGreaterThan(denom, a) == 1.0) {\n                break;\n            } \n            if (denom[BYTE_COUNT-1] >= 128.0) {\n                overflow = true;\n                break;\n            }\n            biguintLshiftByOne(current);\n            biguintLshiftByOne(denom);\n        }\n        if (!overflow) {\n            biguintRshiftByOne(denom);\n            biguintRshiftByOne(current);\n        }\n        for (int i = 0; i < 8*BYTE_COUNT; i++) {\n            float isZero = 1.0;\n            for (int j = 0; j < BYTE_COUNT; j++) isZero -= isZero * neq(current[j], 0.0);\n            if (isZero == 1.0) break;\n            if (biguintGreaterThanOrEqual(t1, denom) == 1.0) {\n                biguintSub(t1, denom, t1);\n                biguintOr(c, current, c);\n            }\n            biguintRshiftByOne(current);\n            biguintRshiftByOne(denom);\n        }\n    }\n}\n\nvoid biguintDiv(float a[BYTE_COUNT], float bf, inout float c[BYTE_COUNT]) {\n    float b[BYTE_COUNT];\n    biguintAssign(b, bf);\n    biguintDiv(a, b, c);\n}",declarations:["void biguintDiv(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);","void biguintDiv(float [BYTE_COUNT], float, inout float [BYTE_COUNT]);"]},biguintEquals:{source:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nfloat gt(float, float);\nfloat lt(float, float);\nfloat eq(float, float);\n\nvoid biguintAssign(inout float [BYTE_COUNT], float);\n\nfloat biguintEquals(float a[BYTE_COUNT], float b[BYTE_COUNT]) {\n    float cmp;\n    for (int i = BYTE_COUNT - 1; i >= 0; i--)\n        cmp += eq(cmp, 0.0) * gt(floor(a[i]), floor(b[i]))\n             - eq(cmp, 0.0) * lt(floor(a[i]), floor(b[i]));\n    return eq(cmp, 0.0);\n}\n\nfloat biguintEquals(float a[BYTE_COUNT], float bf) {\n    float b[BYTE_COUNT];\n    biguintAssign(b, bf);\n    return biguintEquals(a, b);\n}",declarations:["float biguintEquals(float [BYTE_COUNT], float [BYTE_COUNT]);","float biguintEquals(float [BYTE_COUNT], float);"]},biguintGreaterThan:{source:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nfloat gt(float, float);\nfloat lt(float, float);\nfloat eq(float, float);\n\nvoid biguintAssign(inout float [BYTE_COUNT], float);\n\nfloat biguintGreaterThan(float a[BYTE_COUNT], float b[BYTE_COUNT]) {\n    float cmp;\n    for (int i = BYTE_COUNT - 1; i >= 0; i--)\n        cmp += eq(cmp, 0.0) * gt(floor(a[i]), floor(b[i]))\n             - eq(cmp, 0.0) * lt(floor(a[i]), floor(b[i]));\n    return eq(cmp, 1.0);\n}\n\nfloat biguintGreaterThan(float a[BYTE_COUNT], float bf) {\n    float b[BYTE_COUNT];\n    biguintAssign(b, bf);\n    return biguintGreaterThan(a, b);\n}",declarations:["float biguintGreaterThan(float [BYTE_COUNT], float [BYTE_COUNT]);","float biguintGreaterThan(float [BYTE_COUNT], float);"]},biguintGreaterThanOrEqual:{source:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nfloat gt(float, float);\nfloat lt(float, float);\nfloat eq(float, float);\n\nvoid biguintAssign(inout float [BYTE_COUNT], float);\n\nfloat biguintGreaterThanOrEqual(float a[BYTE_COUNT], float b[BYTE_COUNT]) {\n    float cmp;\n    for (int i = BYTE_COUNT - 1; i >= 0; i--)\n        cmp += eq(cmp, 0.0) * gt(floor(a[i]), floor(b[i]))\n             - eq(cmp, 0.0) * lt(floor(a[i]), floor(b[i]));\n    return gt(cmp, -1.0);\n}\n\nfloat biguintGreaterThanOrEqual(float a[BYTE_COUNT], float bf) {\n    float b[BYTE_COUNT];\n    biguintAssign(b, bf);\n    return biguintGreaterThanOrEqual(a, b);\n}",declarations:["float biguintGreaterThanOrEqual(float [BYTE_COUNT], float [BYTE_COUNT]);","float biguintGreaterThanOrEqual(float [BYTE_COUNT], float);"]},biguintLessThan:{source:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nfloat gt(float, float);\nfloat lt(float, float);\nfloat eq(float, float);\n\nvoid biguintAssign(inout float [BYTE_COUNT], float);\n\nfloat biguintLessThan(float a[BYTE_COUNT], float b[BYTE_COUNT]) {\n    float cmp;\n    for (int i = BYTE_COUNT - 1; i >= 0; i--)\n        cmp += eq(cmp, 0.0) * gt(floor(a[i]), floor(b[i]))\n             - eq(cmp, 0.0) * lt(floor(a[i]), floor(b[i]));\n    return eq(cmp, -1.0);\n}\n\nfloat biguintLessThan(float a[BYTE_COUNT], float bf) {\n    float b[BYTE_COUNT];\n    biguintAssign(b, bf);\n    return biguintLessThan(a, b);\n}",declarations:["float biguintLessThan(float [BYTE_COUNT], float [BYTE_COUNT]);","float biguintLessThan(float [BYTE_COUNT], float);"]},biguintLessThanOrEqual:{source:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nfloat gt(float, float);\nfloat lt(float, float);\nfloat eq(float, float);\n\nvoid biguintAssign(inout float [BYTE_COUNT], float);\n\nfloat biguintLessThanOrEqual(float a[BYTE_COUNT], float b[BYTE_COUNT]) {\n    float cmp;\n    for (int i = BYTE_COUNT - 1; i >= 0; i--)\n        cmp += eq(cmp, 0.0) * gt(floor(a[i]), floor(b[i]))\n             - eq(cmp, 0.0) * lt(floor(a[i]), floor(b[i]));\n    return lt(cmp, 1.0);\n}\n\nfloat biguintLessThanOrEqual(float a[BYTE_COUNT], float bf) {\n    float b[BYTE_COUNT];\n    biguintAssign(b, bf);\n    return biguintLessThanOrEqual(a, b);\n}",declarations:["float biguintLessThanOrEqual(float [BYTE_COUNT], float [BYTE_COUNT]);","float biguintLessThanOrEqual(float [BYTE_COUNT], float);"]},biguintLshift:{source:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nfloat neq(float, float);\n\nvoid biguintLshiftWord(inout float [BYTE_COUNT], float);\nfloat biguintLshiftByte(float, float);\nvoid biguintRshiftWord(inout float [BYTE_COUNT], float);\nfloat biguintRshiftByte(float, float);\nfloat biguintOrByte(float, float);\nvoid biguintAssign(inout float [BYTE_COUNT], float [BYTE_COUNT]);\nvoid biguintAssignIfTrue(inout float [BYTE_COUNT], float [BYTE_COUNT], float);\n\nvoid biguintLshift(float a[BYTE_COUNT], inout float b[BYTE_COUNT], float count) {\n    count = clamp(floor(count), 0.0, float(BYTE_COUNT*8));\n    biguintAssign(b, a);\n    biguintLshiftWord(b, floor(count / 8.0));\n    float bits = mod(count, 8.0);\n    float t1[BYTE_COUNT];\n    biguintAssign(t1, b);\n    for (int i = BYTE_COUNT - 1; i > 0; i--) \n        t1[i] = biguintOrByte(biguintLshiftByte(t1[i], bits), \n                              biguintRshiftByte(t1[i-1], 8.0-bits));\n    t1[0] = biguintLshiftByte(t1[0], bits);\n    biguintAssignIfTrue(b, t1, neq(bits, 0.0));\n}",declarations:["void biguintLshift(float [BYTE_COUNT], inout float [BYTE_COUNT], float);"]},biguintLshiftByOne:{source:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nfloat biguintLshiftByte(float, float);\nfloat biguintRshiftByte(float, float);\nfloat biguintOrByte(float, float);\n\nvoid biguintLshiftByOne(inout float a[BYTE_COUNT]) {\n    for (int i = BYTE_COUNT - 1; i > 0; i--) \n        a[i] = biguintOrByte(biguintLshiftByte(a[i], 1.0), \n                             biguintRshiftByte(a[i-1], 8.0-1.0));\n    a[0] = biguintLshiftByte(a[0], 1.0);\n}",declarations:["void biguintLshiftByOne(inout float [BYTE_COUNT]);"]},biguintLshiftByte:{source:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nfloat eq(float, float);\n\nfloat biguintLshiftByte(float i, float m) {\n    return mod(floor(i * eq(m, 0.0)\n                   + i * eq(m, 1.0) * 2.0\n                   + i * eq(m, 2.0) * 4.0\n                   + i * eq(m, 3.0) * 8.0\n                   + i * eq(m, 4.0) * 16.0\n                   + i * eq(m, 5.0) * 32.0\n                   + i * eq(m, 6.0) * 64.0\n                   + i * eq(m, 7.0) * 128.0), 256.0);\n}",declarations:["float biguintLshiftByte(float, float);"]},biguintLshiftWord:{source:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nvoid biguintLshiftWord(inout float a[BYTE_COUNT], float count) {\n    for (int i = BYTE_COUNT - 1; i >= 0; i--)\n        a[i] = a[int(max(float(i)-count, 0.0))] \n             * float(float(i)-count >= 0.0);\n}",declarations:["void biguintLshiftWord(inout float [BYTE_COUNT], float);"]},biguintMod:{source:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nvoid biguintDiv(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);\nvoid biguintMul(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);\nvoid biguintSub(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);\nvoid biguintLshift(float [BYTE_COUNT], inout float [BYTE_COUNT], float);\nvoid biguintAssign(inout float [BYTE_COUNT], float);\n\nvoid biguintMod(float ia[BYTE_COUNT], float ib[BYTE_COUNT], inout float oc[BYTE_COUNT]) {\n\tfloat tc[BYTE_COUNT];\n\tbiguintDiv(ia, ib, oc);\n    biguintMul(oc, ib, tc);\n    biguintSub(ia, tc, oc);\n}\n\nvoid biguintMod(float ia[BYTE_COUNT], float ibf, inout float oc[BYTE_COUNT]) {\n    float ib[BYTE_COUNT], tc[BYTE_COUNT];\n    biguintAssign(ib, ibf);\n    biguintDiv(ia, ib, oc);\n    biguintMul(oc, ib, tc);\n    biguintSub(ia, tc, oc);\n}",declarations:["void biguintMod(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);","void biguintMod(float [BYTE_COUNT], float, inout float [BYTE_COUNT]);"]},biguintMul:{source:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nfloat eq(float, float);\nfloat neq(float, float);\n\nvoid biguintLshift(float [BYTE_COUNT], inout float [BYTE_COUNT], float);\nvoid biguintAssign(inout float [BYTE_COUNT], float);\n\nvoid biguintMul(float a[BYTE_COUNT], float b[BYTE_COUNT], inout float c[BYTE_COUNT]) {\n    float nonEmptyBytes, powerOfTwoBit;\n    for (int i = 0; i < BYTE_COUNT; i++) {\n        nonEmptyBytes += neq(b[i], 0.0);\n        powerOfTwoBit = float(i*8+0) * eq(b[i], 1.0)\n                      + float(i*8+1) * eq(b[i], 2.0)\n                      + float(i*8+2) * eq(b[i], 4.0)\n                      + float(i*8+3) * eq(b[i], 8.0)\n                      + float(i*8+4) * eq(b[i], 16.0)\n                      + float(i*8+5) * eq(b[i], 32.0)\n                      + float(i*8+6) * eq(b[i], 64.0)\n                      + float(i*8+7) * eq(b[i], 128.0);\n    }\n    if (nonEmptyBytes == 1.0 && powerOfTwoBit != 0.0) {\n        biguintLshift(a, c, powerOfTwoBit);\n    } else {\n        float product, carry;\n        float t1[BYTE_COUNT*2];\n        for (int i = 0; i < BYTE_COUNT; i++) {\n            for (int j = 0; j < BYTE_COUNT; j++) {\n                product = a[i] * b[j] + t1[i+j];\n                carry = floor(product / 256.0);\n                t1[i+j] = product - carry * 256.0;\n                t1[i+j+1] += carry;\n            }\n        }\n        float isOver = 0.0;\n        for (int i = BYTE_COUNT; i < 2*BYTE_COUNT; i++) isOver += (1.0 - isOver) * neq(t1[i], 0.0);\n        for (int i = 0; i < BYTE_COUNT; i++) c[i] = t1[i] * (1.0 - isOver) + 255.0 * isOver;\n    }\n}\n\nvoid biguintMul(float a[BYTE_COUNT], float bf, inout float c[BYTE_COUNT]) {\n    float b[BYTE_COUNT];\n    biguintAssign(b, bf);\n    biguintMul(a, b, c);\n}",declarations:["void biguintMul(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);","void biguintMul(float [BYTE_COUNT], float, inout float [BYTE_COUNT]);"]},biguintOr:{source:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nfloat gte(float, float);\n\nvoid biguintOr(float a[BYTE_COUNT], float b[BYTE_COUNT], inout float c[BYTE_COUNT]) {\n    for (int i = 0; i < BYTE_COUNT; i++) {\n        float o = max(gte(a[i], 128.0), gte(b[i], 128.0)) * 128.0;\n        a[i] -= gte(a[i], 128.0) * 128.0;\n        b[i] -= gte(b[i], 128.0) * 128.0;\n        o += max(gte(a[i], 64.0), gte(b[i], 64.0)) * 64.0;\n        a[i] -= gte(a[i], 64.0) * 64.0;\n        b[i] -= gte(b[i], 64.0) * 64.0;\n        o += max(gte(a[i], 32.0), gte(b[i], 32.0)) * 32.0;\n        a[i] -= gte(a[i], 32.0) * 32.0;\n        b[i] -= gte(b[i], 32.0) * 32.0;\n        o += max(gte(a[i], 16.0), gte(b[i], 16.0)) * 16.0;\n        a[i] -= gte(a[i], 16.0) * 16.0;\n        b[i] -= gte(b[i], 16.0) * 16.0;\n        o += max(gte(a[i], 8.0), gte(b[i], 8.0)) * 8.0;\n        a[i] -= gte(a[i], 8.0) * 8.0;\n        b[i] -= gte(b[i], 8.0) * 8.0;\n        o += max(gte(a[i], 4.0), gte(b[i], 4.0)) * 4.0;\n        a[i] -= gte(a[i], 4.0) * 4.0;\n        b[i] -= gte(b[i], 4.0) * 4.0;\n        o += max(gte(a[i], 2.0), gte(b[i], 2.0)) * 2.0;\n        a[i] -= gte(a[i], 2.0) * 2.0;\n        b[i] -= gte(b[i], 2.0) * 2.0;\n        c[i] = o + max(gte(a[i], 1.0), gte(b[i], 1.0));\n    }\n}",declarations:["void biguintOr(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);"]},biguintOrByte:{source:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nfloat gte(float, float);\n\nfloat biguintOrByte(float a, float b) {\n    float o = max(gte(a, 128.0), gte(b, 128.0)) * 128.0;\n    a -= gte(a, 128.0) * 128.0;\n    b -= gte(b, 128.0) * 128.0;\n    o += max(gte(a, 64.0), gte(b, 64.0)) * 64.0;\n    a -= gte(a, 64.0) * 64.0;\n    b -= gte(b, 64.0) * 64.0;\n    o += max(gte(a, 32.0), gte(b, 32.0)) * 32.0;\n    a -= gte(a, 32.0) * 32.0;\n    b -= gte(b, 32.0) * 32.0;\n    o += max(gte(a, 16.0), gte(b, 16.0)) * 16.0;\n    a -= gte(a, 16.0) * 16.0;\n    b -= gte(b, 16.0) * 16.0;\n    o += max(gte(a, 8.0), gte(b, 8.0)) * 8.0;\n    a -= gte(a, 8.0) * 8.0;\n    b -= gte(b, 8.0) * 8.0;\n    o += max(gte(a, 4.0), gte(b, 4.0)) * 4.0;\n    a -= gte(a, 4.0) * 4.0;\n    b -= gte(b, 4.0) * 4.0;\n    o += max(gte(a, 2.0), gte(b, 2.0)) * 2.0;\n    a -= gte(a, 2.0) * 2.0;\n    b -= gte(b, 2.0) * 2.0;\n    return o + max(gte(a, 1.0), gte(b, 1.0));\n}",declarations:["float biguintOrByte(float, float);"]},biguintPow:{source:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nvoid biguintSub(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);\nvoid biguintMul(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);\nvoid biguintAssign(inout float [BYTE_COUNT], float [BYTE_COUNT]);\nvoid biguintAssignIfTrue(inout float [BYTE_COUNT], float [BYTE_COUNT], float);\n\nvoid biguintPow(float a[BYTE_COUNT], float bf, inout float c[BYTE_COUNT]) {\n    bf = max(floor(bf), 0.0);\n    c[0] = 1.0;\n    for (int i = 1; i < BYTE_COUNT; i++) c[i] = 0.0;\n    biguintAssignIfTrue(c, a, float(bf != 0.0));\n    for (int i = 0; i < 65536; i++) {\n        if (bf <= 1.0) break;\n        biguintMul(c, a, c);\n        bf -= 1.0;\n    }\n}",declarations:["void biguintPow(float [BYTE_COUNT], float, inout float [BYTE_COUNT]);"]},biguintRshift:{source:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nfloat neq(float, float);\n\nvoid biguintLshiftWord(inout float [BYTE_COUNT], float);\nfloat biguintLshiftByte(float, float);\nvoid biguintRshiftWord(inout float [BYTE_COUNT], float);\nfloat biguintRshiftByte(float, float);\nfloat biguintOrByte(float, float);\nvoid biguintAssign(inout float [BYTE_COUNT], float [BYTE_COUNT]);\nvoid biguintAssignIfTrue(inout float [BYTE_COUNT], float [BYTE_COUNT], float);\n\nvoid biguintRshift(float a[BYTE_COUNT], inout float b[BYTE_COUNT], float count) {\n    count = clamp(floor(count), 0.0, float(BYTE_COUNT*8));\n    biguintAssign(b, a);\n    biguintRshiftWord(b, floor(count / 8.0));\n    float bits = mod(count, 8.0);\n    float t1[BYTE_COUNT];\n    biguintAssign(t1, b);\n    for (int i = 0; i < BYTE_COUNT - 1; i++)\n        t1[i] = biguintOrByte(biguintRshiftByte(t1[i], bits),\n                              biguintLshiftByte(t1[i+1], 8.0-bits));\n    t1[BYTE_COUNT-1] = biguintRshiftByte(t1[BYTE_COUNT-1], bits);\n    biguintAssignIfTrue(b, t1, neq(bits, 0.0));\n}",declarations:["void biguintRshift(float [BYTE_COUNT], inout float [BYTE_COUNT], float);"]},biguintRshiftByOne:{source:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nfloat biguintLshiftByte(float, float);\nfloat biguintRshiftByte(float, float);\nfloat biguintOrByte(float, float);\n\nvoid biguintRshiftByOne(inout float a[BYTE_COUNT]) {\n    for (int i = 0; i < BYTE_COUNT - 1; i++)\n        a[i] = biguintOrByte(biguintRshiftByte(a[i], 1.0),\n                             biguintLshiftByte(a[i+1], 8.0-1.0));\n    a[BYTE_COUNT-1] = biguintRshiftByte(a[BYTE_COUNT-1], 1.0);\n}",declarations:["void biguintRshiftByOne(inout float [BYTE_COUNT]);"]},biguintRshiftByte:{source:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nfloat eq(float, float);\n\nfloat biguintRshiftByte(float i, float m) {\n    return floor(i * eq(m, 0.0)\n               + i * eq(m, 1.0) / 2.0\n               + i * eq(m, 2.0) / 4.0\n               + i * eq(m, 3.0) / 8.0\n               + i * eq(m, 4.0) / 16.0\n               + i * eq(m, 5.0) / 32.0\n               + i * eq(m, 6.0) / 64.0\n               + i * eq(m, 7.0) / 128.0);\n}",declarations:["float biguintRshiftByte(float, float);"]},biguintRshiftWord:{source:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nfloat lt(float, float);\n\nvoid biguintRshiftWord(inout float a[BYTE_COUNT], float count) {\n    for (int i = 0; i < BYTE_COUNT; i++) \n        a[i] = a[int(min(float(i)+count, float(BYTE_COUNT) - 1.0))]\n             * lt(float(i)+count, float(BYTE_COUNT));\n}",declarations:["void biguintRshiftWord(inout float [BYTE_COUNT], float);"]},biguintSqrt:{source:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nvoid biguintRshift(float [BYTE_COUNT], inout float [BYTE_COUNT], float);\nvoid biguintAdd(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);\nvoid biguintAdd(float [BYTE_COUNT], float, inout float [BYTE_COUNT]);\nfloat biguintLessThan(float [BYTE_COUNT], float [BYTE_COUNT]);\nfloat biguintLessThanOrEqual(float [BYTE_COUNT], float [BYTE_COUNT]);\nfloat biguintGreaterThan(float [BYTE_COUNT], float [BYTE_COUNT]);\nfloat biguintGreaterThanOrEqual(float [BYTE_COUNT], float [BYTE_COUNT]);\nvoid biguintMul(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);\nvoid biguintSub(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);\nvoid biguintSub(float [BYTE_COUNT], float, inout float [BYTE_COUNT]);\nvoid biguintAssign(inout float [BYTE_COUNT], float [BYTE_COUNT]);\nvoid biguintAssignIfTrue(inout float [BYTE_COUNT], float [BYTE_COUNT], float);\nvoid biguintRshiftByOne(inout float [BYTE_COUNT]);\n\nvoid biguintSqrt(inout float a[BYTE_COUNT]) {\n    float low[BYTE_COUNT], high[BYTE_COUNT], mid[BYTE_COUNT], t1[BYTE_COUNT];\n    biguintAssign(high, a);\n    biguintRshift(high, mid, 1.0);\n    biguintAdd(mid, 1.0, mid);\n    for (int i = 0; i < BYTE_COUNT * 8; i++) {\n        if (biguintLessThanOrEqual(high, low) == 1.0) break;\n        biguintMul(mid, mid, t1);\n        float isGreaterThan = biguintGreaterThan(t1, a);\n        biguintAssign(t1, mid);\n        biguintSub(t1, 1.0, t1);\n        biguintAssignIfTrue(high, t1, isGreaterThan);\n\t\tbiguintAssignIfTrue(low, mid, 1.0 - isGreaterThan);\n\t\tbiguintSub(high, low, mid);\n        biguintRshiftByOne(mid);\n        biguintAdd(low, mid, mid);\n        biguintAdd(mid, 1.0, mid);\n    }\n    biguintAssign(a, low);\n}\n\nvoid biguintSqrt(float a[BYTE_COUNT], inout float b[BYTE_COUNT]) {\n    biguintAssign(b, a);\n    biguintSqrt(b);\n}",declarations:["void biguintSqrt(float [BYTE_COUNT], inout float [BYTE_COUNT]);"]},biguintSub:{source:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nfloat lt(float, float);\n\nvoid biguintAssign(inout float [BYTE_COUNT], float);\n\nvoid biguintSub(float a[BYTE_COUNT], float b[BYTE_COUNT], inout float c[BYTE_COUNT]) {\n    float borrow, tmp;\n    for (int i = 0; i < BYTE_COUNT; i++) {\n        tmp = a[i] - b[i] - borrow;\n        borrow = lt(tmp, 0.0);\n        c[i] = mod(tmp, 256.0); \n    }\n}\n\nvoid biguintSub(float a[BYTE_COUNT], float bf, inout float c[BYTE_COUNT]) {\n    float b[BYTE_COUNT];\n    biguintAssign(b, bf);\n    biguintSub(a, b, c);\n}",declarations:["void biguintSub(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);","void biguintSub(float [BYTE_COUNT], float, inout float [BYTE_COUNT]);"]},biguintXor:{source:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nfloat neq(float, float);\nfloat gte(float, float);\n\nvoid biguintXor(float a[BYTE_COUNT], float b[BYTE_COUNT], inout float c[BYTE_COUNT]) {\n    for (int i = 0; i < BYTE_COUNT; i++) {\n        float o = neq(gte(a[i], 128.0), gte(b[i], 128.0)) * 128.0;\n        a[i] -= gte(a[i], 128.0) * 128.0;\n        b[i] -= gte(b[i], 128.0) * 128.0;\n        o += neq(gte(a[i], 64.0), gte(b[i], 64.0)) * 64.0;\n        a[i] -= gte(a[i], 64.0) * 64.0;\n        b[i] -= gte(b[i], 64.0) * 64.0;\n        o += neq(gte(a[i], 32.0), gte(b[i], 32.0)) * 32.0;\n        a[i] -= gte(a[i], 32.0) * 32.0;\n        b[i] -= gte(b[i], 32.0) * 32.0;\n        o += neq(gte(a[i], 16.0), gte(b[i], 16.0)) * 16.0;\n        a[i] -= gte(a[i], 16.0) * 16.0;\n        b[i] -= gte(b[i], 16.0) * 16.0;\n        o += neq(gte(a[i], 8.0), gte(b[i], 8.0)) * 8.0;\n        a[i] -= gte(a[i], 8.0) * 8.0;\n        b[i] -= gte(b[i], 8.0) * 8.0;\n        o += neq(gte(a[i], 4.0), gte(b[i], 4.0)) * 4.0;\n        a[i] -= gte(a[i], 4.0) * 4.0;\n        b[i] -= gte(b[i], 4.0) * 4.0;\n        o += neq(gte(a[i], 2.0), gte(b[i], 2.0)) * 2.0;\n        a[i] -= gte(a[i], 2.0) * 2.0;\n        b[i] -= gte(b[i], 2.0) * 2.0;\n        c[i] = o + neq(gte(a[i], 1.0), gte(b[i], 1.0));\n    }\n}",declarations:["void biguintXor(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);"]}})),t.rendered=T.render(t.dependencies,l.commonStutters)},function(n,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.ComputeShader=t.passThruFrag=t.passThruVert=void 0;const e=i(1);t.passThruVert="\n#ifdef GL_ES\nprecision mediump float;\nprecision mediump int;\nprecision mediump sampler2D;\n#endif\n\nattribute vec3 a_position;\n\nvoid main() {\n  gl_Position = vec4(a_position, 1.0);\n}",t.passThruFrag="\n#ifdef GL_ES\nprecision mediump float;\nprecision mediump int;\nprecision mediump sampler2D;\n#endif\n\nuniform sampler2D u_tex;\nuniform float u_textureWidth;\n\nvoid main() {\n  gl_FragColor = texture2D(u_tex, gl_FragCoord.xy / u_textureWidth);\n}";t.ComputeShader=class{constructor(n,i,o,a){a=a?e.setWebGLContext(a):e.getWebGLContext(),this.vertShader=this.createVertShader(this.searchAndReplace(o||t.passThruVert,i)),this.fragShader=this.createFragShader(this.searchAndReplace(n,i)),this.program=this.createProgram(this.vertShader,this.fragShader),this.attributeInfo=this.getAttributeInfo(a,this.program),this.uniformInfo=this.getUniformInfo(a,this.program)}delete(){const n=e.getWebGLContext();n.deleteShader(this.vertShader),n.deleteShader(this.fragShader),n.deleteProgram(this.program)}preprocess(n){return(n=(n=(n=n.replace(/\t/g,"    ")).replace(/\r+/gm,"")).replace(/\n{3,}/g,"\n\n")).trim()}createVertShader(n){const t=e.getWebGLContext(),i=t.createShader(t.VERTEX_SHADER);if(!i)throw new Error("unable to create new vertex shader");if(t.shaderSource(i,this.preprocess(n)),t.compileShader(i),!t.getShaderParameter(i,t.COMPILE_STATUS))throw new Error(`could not compile vertex shader: ${t.getShaderInfoLog(i)}\n\n${n.trim()}`);return i}createFragShader(n){const t=e.getWebGLContext(),i=t.createShader(t.FRAGMENT_SHADER);if(!i)throw new Error("unable to create new fragment shader");if(t.shaderSource(i,this.preprocess(n)),t.compileShader(i),!t.getShaderParameter(i,t.COMPILE_STATUS))throw new Error(`could not compile fragment shader: ${t.getShaderInfoLog(i)}\n\n${n.trim()}`);return i}createProgram(n,t){const i=e.getWebGLContext();var o=i.createProgram();if(!o)throw new Error("unable to create program");if(i.attachShader(o,n),i.attachShader(o,t),i.linkProgram(o),!i.getProgramParameter(o,i.LINK_STATUS))throw new Error("error in program linking: "+i.getProgramInfoLog(o));return o}searchAndReplace(n,t){if(t)for(var[i,e]of Object.entries(t))n=n.replace(i,e);return n}getAttributeInfo(n,t){const i={},e=n.getProgramParameter(t,n.ACTIVE_ATTRIBUTES);for(let o=0;o<e;o++){const e=n.getActiveAttrib(t,o);if(null===e)continue;const a=n.getAttribLocation(t,e.name);null!==a&&(i[e.name]={size:e.size,type:e.type,location:a})}return i}getUniformInfo(n,t){const i={},e=n.getProgramParameter(t,n.ACTIVE_UNIFORMS);for(let o=0;o<e;o++){const e=n.getActiveUniform(t,o);if(null===e)continue;const a=n.getUniformLocation(t,e.name);null!==a&&(i[e.name]={size:e.size,type:e.type,location:a})}return i}}},function(n,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.rendered=t.dependencies=void 0;const e=i(0),o=i(2);t.dependencies=o.getDependencies({eq:{source:"#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nfloat eq(float x, float y) {\n    return 1.0 - abs(sign(x - y));\n}",declarations:["float eq(float, float);"]},gt:{source:"#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nfloat gt(float x, float y) {\n    return max(sign(x - y), 0.0);\n}",declarations:["float gt(float, float);"]},gte:{source:"#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nfloat lt(float, float);\n\nfloat gte(float x, float y) {\n    return 1.0 - lt(x, y);\n}",declarations:["float gte(float, float);"]},int16FromVec2:{source:"#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nfloat int16FromVec2(vec2 v) {\n    return clamp(floor(floor(v.r * 255.0) * 256.0) + floor(v.g * 255.0) - 32767.0, -32767.0, 32768.0);\n}",declarations:["float int16FromVec2(vec2);"]},int16ToVec2:{source:"#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nvec2 int16ToVec2(float f) {\n    f = clamp(f, -32767.0, 32768.0) + 32767.0; \n    return vec2(floor(f / 256.0), f - floor(f / 256.0) * 256.0) / 255.0; \n}",declarations:["vec2 int16ToVec2(float);"]},lt:{source:"#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nfloat lt(float x, float y) {\n    return max(sign(y - x), 0.0);\n}",declarations:["float lt(float, float);"]},lte:{source:"#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nfloat gt(float, float);\n\nfloat lte(float x, float y) {\n    return 1.0 - gt(x, y);\n}",declarations:["float lte(float, float);"]},neq:{source:"#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nfloat neq(float x, float y) {\n    return abs(sign(x - y));\n}",declarations:["float neq(float, float);"]},packBooleans:{source:"#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nfloat packBooleans(bool arr[8]) {\n    return (\n        float(arr[0]) * 128.0\n      + float(arr[1]) * 64.0\n      + float(arr[2]) * 32.0\n      + float(arr[3]) * 16.0\n      + float(arr[4]) * 8.0\n      + float(arr[5]) * 4.0\n      + float(arr[6]) * 2.0\n      + float(arr[7])\n    ) / 255.0;\n}",declarations:["float packBooleans(bool [8]);"]},round:{source:"#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nfloat round(float f) {\n    return floor(f + 0.5);\n}",declarations:["float round(float);"]},uint16FromVec2:{source:"#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nfloat uint16FromVec2(vec2 v) {\n    return clamp(floor(floor(v.r * 255.0) * 256.0) + floor(v.g * 255.0), 0.0, 65535.0);\n}",declarations:["float uint16FromVec2(vec2);"]},uint16ToVec2:{source:"#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nvec2 uint16ToVec2(float f) {\n    f = clamp(f, 0.0, 65535.0); \n    return vec2(floor(f / 256.0), f - floor(f / 256.0) * 256.0) / 255.0; \n}",declarations:["vec2 uint16ToVec2(float);"]},unpackBooleans:{source:"#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nvoid unpackBooleans(float f, inout bool arr[8]) {\n    f = floor(f * 255.0);\n    arr[0] = f >= 128.0;\n    f -= float(arr[0]) * 128.0;\n    arr[1] = f >= 64.0;\n    f -= float(arr[1]) * 64.0;\n    arr[2] = f >= 32.0;\n    f -= float(arr[2]) * 32.0;\n    arr[3] = f >= 16.0;\n    f -= float(arr[3]) * 16.0;\n    arr[4] = f >= 8.0;\n    f -= float(arr[4]) * 8.0;\n    arr[5] = f >= 4.0;\n    f -= float(arr[5]) * 4.0;\n    arr[6] = f >= 2.0;\n    f -= float(arr[6]) * 2.0;\n    arr[7] = f >= 1.0;\n}",declarations:["void unpackBooleans(float, inout bool [8]);"]}}),t.rendered=o.render(t.dependencies,e.commonStutters)},function(n,t,i){"use strict";var e=this&&this.__createBinding||(Object.create?function(n,t,i,e){void 0===e&&(e=i),Object.defineProperty(n,e,{enumerable:!0,get:function(){return t[i]}})}:function(n,t,i,e){void 0===e&&(e=i),n[e]=t[i]}),o=this&&this.__setModuleDefault||(Object.create?function(n,t){Object.defineProperty(n,"default",{enumerable:!0,value:t})}:function(n,t){n.default=t}),a=this&&this.__importStar||function(n){if(n&&n.__esModule)return n;var t={};if(null!=n)for(var i in n)Object.hasOwnProperty.call(n,i)&&e(t,n,i);return o(t,n),t};Object.defineProperty(t,"__esModule",{value:!0}),t.rendered=t.dependencies=t.encodeSignedBytes=t.decodeSignedBytes=void 0;const f=a(i(5)),r=a(i(3)),l=i(0),T=i(2),s=i(9);t.decodeSignedBytes=function(n,t){const i=s.removeTwosComplement(n);t&&n.reverse();const e=BigInt("0x"+s.bytesToHex(n))*(i?BigInt(-1):BigInt(1));return s.applyTwosComplement(n,i),e},t.encodeSignedBytes=function(n,t,i){const e=n<BigInt(0);e&&(n*=BigInt(-1));const o=s.resizeBytes(s.hexToBytes(n.toString(16)),t,i);return s.applyTwosComplement(o,e),i&&o.reverse(),o},t.dependencies=T.merge(f.dependencies,r.dependencies,T.getDependencies({bigintAbs:{source:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nbool bigintRemoveTwosComplement(inout float [BYTE_COUNT]);\nvoid bigintApplyTwosComplement(inout float [BYTE_COUNT], bool);\n\nvoid bigintAbs(inout float a[BYTE_COUNT]) {\n    bigintRemoveTwosComplement(a);\n    bigintApplyTwosComplement(a, false);\n}",declarations:["void bigintAbs(inout float [BYTE_COUNT]);"]},bigintAdd:{source:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nvoid biguintAdd(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);\nvoid bigintAssign(inout float [BYTE_COUNT], float);\n\nvoid bigintAdd(float a[BYTE_COUNT], float b[BYTE_COUNT], inout float c[BYTE_COUNT]) {\n    biguintAdd(a, b, c);\n}\n\nvoid bigintAdd(float a[BYTE_COUNT], float bf, inout float c[BYTE_COUNT]) {\n    float b[BYTE_COUNT];\n    bigintAssign(b, bf);\n    bigintAdd(a, b, c);\n}",declarations:["void bigintAdd(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);","void bigintAdd(float [BYTE_COUNT], float, inout float [BYTE_COUNT]);"]},bigintAnd:{source:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nvoid biguintAnd(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);\n\nvoid bigintAnd(float a[BYTE_COUNT], float b[BYTE_COUNT], inout float c[BYTE_COUNT]) {\n    biguintAnd(a, b, c);\n}",declarations:["void bigintAnd(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);"]},bigintApplyTwosComplement:{source:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nfloat gte(float, float);\n\nvoid biguintAdd(float [BYTE_COUNT], float, inout float [BYTE_COUNT]);\n\nvoid bigintApplyTwosComplement(inout float a[BYTE_COUNT], float negative) {\n    a[BYTE_COUNT-1] -= gte(a[BYTE_COUNT-1], 128.0) * 128.0;\n    for (int i = 0; i < BYTE_COUNT; i++) {\n        a[i] = a[i] * (1.0 - negative)\n             + (255.0 - a[i]) * negative;\n    }\n    biguintAdd(a, negative, a);\n}\n\nvoid bigintApplyTwosComplement(inout float a[BYTE_COUNT], bool negative) {\n    bigintApplyTwosComplement(a, float(negative));\n}",declarations:["void bigintApplyTwosComplement(inout float [BYTE_COUNT], float);","void bigintApplyTwosComplement(inout float [BYTE_COUNT], bool);"]},bigintAssign:{source:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nvoid bigintApplyTwosComplement(inout float [BYTE_COUNT], float);\n\nvoid bigintAssign(inout float dst[BYTE_COUNT], float src[BYTE_COUNT]) {\n    for (int i = 0; i < BYTE_COUNT; i++) dst[i] = src[i];\n}\n\nvoid bigintAssign(inout float dst[BYTE_COUNT], float f) {\n    float isNegative = float(f < 0.0);\n    f = min(abs(floor(f)), 65535.0);\n    dst[0] = mod(f, 256.0);\n    dst[1] = floor(f / 256.0);\n    for (int i = 2; i < BYTE_COUNT; i++) dst[i] = 0.0;\n    bigintApplyTwosComplement(dst, isNegative);\n}",declarations:["void bigintAssign(inout float [BYTE_COUNT], float [BYTE_COUNT]);","void bigintAssign(inout float [BYTE_COUNT], float);"]},bigintAssignIfTrue:{source:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nfloat eq(float, float);\nfloat neq(float, float);\n\nvoid bigintAssign(inout float [BYTE_COUNT], float);\n\nvoid bigintAssignIfTrue(inout float dst[BYTE_COUNT], float src[BYTE_COUNT], float f) {\n    for (int i = 0; i < BYTE_COUNT; i++)\n       dst[i] = src[i] * neq(f, 0.0)\n              + dst[i] * eq(f, 0.0);\n}\n\nvoid bigintAssignIfTrue(inout float dst[BYTE_COUNT], float src[BYTE_COUNT], bool b) {\n    bigintAssignIfTrue(dst, src, float(b));\n}\n\nvoid bigintAssignIfTrue(inout float dst[BYTE_COUNT], float sf, float f) {\n    float src[BYTE_COUNT];\n    bigintAssign(dst, sf);\n    bigintAssignIfTrue(dst, src, f);\n}\n\nvoid bigintAssignIfTrue(inout float dst[BYTE_COUNT], float sf, bool b) {\n    float src[BYTE_COUNT];\n    bigintAssign(dst, sf);\n    bigintAssignIfTrue(dst, src, float(b));\n}",declarations:["void bigintAssignIfTrue(inout float [BYTE_COUNT], float [BYTE_COUNT], float);","void bigintAssignIfTrue(inout float [BYTE_COUNT], float [BYTE_COUNT], bool);","void bigintAssignIfTrue(inout float [BYTE_COUNT], float, float);","void bigintAssignIfTrue(inout float [BYTE_COUNT], float, bool);"]},bigintDiv:{source:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nbool bigintRemoveTwosComplement(inout float [BYTE_COUNT]);\nvoid biguintDiv(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);\nvoid bigintApplyTwosComplement(inout float [BYTE_COUNT], bool);\nvoid bigintAssign(inout float [BYTE_COUNT], float);\n\nvoid bigintDiv(float a[BYTE_COUNT], float b[BYTE_COUNT], inout float c[BYTE_COUNT]) {\n    bool aNegative = bigintRemoveTwosComplement(a);\n    bool bNegative = bigintRemoveTwosComplement(b);\n    biguintDiv(a, b, c);\n    bigintApplyTwosComplement(c, aNegative != bNegative);\n}\n\nvoid bigintDiv(float a[BYTE_COUNT], float bf, inout float c[BYTE_COUNT]) {\n    float b[BYTE_COUNT];\n    bigintAssign(b, bf);\n    bigintDiv(a, b, c);\n}",declarations:["void bigintDiv(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);","void bigintDiv(float [BYTE_COUNT], float, inout float [BYTE_COUNT]);"]},bigintEquals:{source:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nfloat gt(float, float);\nfloat lt(float, float);\nfloat eq(float, float);\n\nbool bigintRemoveTwosComplement(inout float [BYTE_COUNT]);\nvoid bigintAssign(inout float [BYTE_COUNT], float);\n\nfloat bigintEquals(float a[BYTE_COUNT], float b[BYTE_COUNT]) {\n    float cmp;\n    bool aNegative = bigintRemoveTwosComplement(a);\n    bool bNegative = bigintRemoveTwosComplement(b);\n    cmp += float(aNegative == false && bNegative == true);\n    cmp -= float(aNegative == true && bNegative == false);\n    for (int i = BYTE_COUNT - 1; i >= 0; i--)\n        cmp += eq(cmp, 0.0) * gt(floor(a[i]), floor(b[i]))\n             - eq(cmp, 0.0) * lt(floor(a[i]), floor(b[i]));\n    return eq(cmp, 0.0);\n}\n\nfloat bigintEquals(float a[BYTE_COUNT], float bf) {\n    float b[BYTE_COUNT];\n    bigintAssign(b, bf);\n    return bigintEquals(a, b);\n}",declarations:["float bigintEquals(float [BYTE_COUNT], float [BYTE_COUNT]);","float bigintEquals(float [BYTE_COUNT], float);"]},bigintGreaterThan:{source:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nfloat gt(float, float);\nfloat lt(float, float);\nfloat eq(float, float);\n\nbool bigintRemoveTwosComplement(inout float [BYTE_COUNT]);\nvoid bigintAssign(inout float [BYTE_COUNT], float);\n\nfloat bigintGreaterThan(float a[BYTE_COUNT], float b[BYTE_COUNT]) {\n    float cmp;\n    bool aNegative = bigintRemoveTwosComplement(a);\n    bool bNegative = bigintRemoveTwosComplement(b);\n    cmp += float(aNegative == false && bNegative == true);\n    cmp -= float(aNegative == true && bNegative == false);\n    for (int i = BYTE_COUNT - 1; i >= 0; i--) {\n        cmp += eq(cmp, 0.0) * gt(floor(a[i]), floor(b[i]))\n             - eq(cmp, 0.0) * lt(floor(a[i]), floor(b[i]));\n    }\n    return eq(cmp, 1.0);\n}\n\nfloat bigintGreaterThan(float a[BYTE_COUNT], float bf) {\n    float b[BYTE_COUNT];\n    bigintAssign(b, bf);\n    return bigintGreaterThan(a, b);\n}",declarations:["float bigintGreaterThan(float [BYTE_COUNT], float [BYTE_COUNT]);","float bigintGreaterThan(float [BYTE_COUNT], float);"]},bigintGreaterThanOrEqual:{source:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nfloat gt(float, float);\nfloat lt(float, float);\nfloat eq(float, float);\n\nbool bigintRemoveTwosComplement(inout float [BYTE_COUNT]);\nvoid bigintAssign(inout float [BYTE_COUNT], float);\n\nfloat bigintGreaterThanOrEqual(float a[BYTE_COUNT], float b[BYTE_COUNT]) {\n    float cmp;\n    bool aNegative = bigintRemoveTwosComplement(a);\n    bool bNegative = bigintRemoveTwosComplement(b);\n    cmp += float(aNegative == false && bNegative == true);\n    cmp -= float(aNegative == true && bNegative == false);\n    for (int i = BYTE_COUNT - 1; i >= 0; i--) {\n        cmp += eq(cmp, 0.0) * gt(floor(a[i]), floor(b[i]))\n             - eq(cmp, 0.0) * lt(floor(a[i]), floor(b[i]));\n    }\n    return gt(cmp, -1.0);\n}\n\nfloat bigintGreaterThanOrEqual(float a[BYTE_COUNT], float bf) {\n    float b[BYTE_COUNT];\n    bigintAssign(b, bf);\n    return bigintGreaterThanOrEqual(a, b);\n}",declarations:["float bigintGreaterThanOrEqual(float [BYTE_COUNT], float [BYTE_COUNT]);","float bigintGreaterThanOrEqual(float [BYTE_COUNT], float);"]},bigintLessThan:{source:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nfloat gt(float, float);\nfloat lt(float, float);\nfloat eq(float, float);\n\nbool bigintRemoveTwosComplement(inout float [BYTE_COUNT]);\nvoid bigintAssign(inout float [BYTE_COUNT], float);\n\nfloat bigintLessThan(float a[BYTE_COUNT], float b[BYTE_COUNT]) {\n    float cmp;\n    bool aNegative = bigintRemoveTwosComplement(a);\n    bool bNegative = bigintRemoveTwosComplement(b);\n    cmp += float(aNegative == false && bNegative == true);\n    cmp -= float(aNegative == true && bNegative == false);\n    for (int i = BYTE_COUNT - 1; i >= 0; i--) {\n        cmp += eq(cmp, 0.0) * gt(floor(a[i]), floor(b[i]))\n             - eq(cmp, 0.0) * lt(floor(a[i]), floor(b[i]));\n    }\n    return eq(cmp, -1.0);\n}\n\nfloat bigintLessThan(float a[BYTE_COUNT], float bf) {\n    float b[BYTE_COUNT];\n    bigintAssign(b, bf);\n    return bigintLessThan(a, b);\n}\n",declarations:["float bigintLessThan(float [BYTE_COUNT], float [BYTE_COUNT]);","float bigintLessThan(float [BYTE_COUNT], float);"]},bigintLessThanOrEqual:{source:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nfloat gt(float, float);\nfloat lt(float, float);\nfloat eq(float, float);\n\nbool bigintRemoveTwosComplement(inout float [BYTE_COUNT]);\nvoid bigintAssign(inout float [BYTE_COUNT], float);\n\nfloat bigintLessThanOrEqual(float a[BYTE_COUNT], float b[BYTE_COUNT]) {\n    float cmp;\n    bool aNegative = bigintRemoveTwosComplement(a);\n    bool bNegative = bigintRemoveTwosComplement(b);\n    cmp += float(aNegative == false && bNegative == true);\n    cmp -= float(aNegative == true && bNegative == false);\n    for (int i = BYTE_COUNT - 1; i >= 0; i--) {\n        cmp += eq(cmp, 0.0) * gt(floor(a[i]), floor(b[i]))\n             - eq(cmp, 0.0) * lt(floor(a[i]), floor(b[i]));\n    }\n    return lt(cmp, 1.0);\n}\n\nfloat bigintLessThanOrEqual(float a[BYTE_COUNT], float bf) {\n    float b[BYTE_COUNT];\n    bigintAssign(b, bf);\n    return bigintLessThanOrEqual(a, b);\n}",declarations:["float bigintLessThanOrEqual(float [BYTE_COUNT], float [BYTE_COUNT]);","float bigintLessThanOrEqual(float [BYTE_COUNT], float);"]},bigintLshift:{source:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nbool bigintRemoveTwosComplement(inout float [BYTE_COUNT]);\nvoid biguintLshift(float [BYTE_COUNT], inout float [BYTE_COUNT], float);\nvoid bigintApplyTwosComplement(inout float [BYTE_COUNT], bool);\n\nvoid bigintLshift(float a[BYTE_COUNT], inout float b[BYTE_COUNT], float f) {\n    bool negative = bigintRemoveTwosComplement(a);\n    biguintLshift(a, b, f);\n    bigintApplyTwosComplement(b, negative);\n}",declarations:["void bigintLshift(float [BYTE_COUNT], inout float [BYTE_COUNT], float);"]},bigintLshiftByOne:{source:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nbool bigintRemoveTwosComplement(inout float [BYTE_COUNT]);\nvoid biguintLshiftByOne(inout float [BYTE_COUNT]);\nvoid bigintApplyTwosComplement(inout float [BYTE_COUNT], bool);\n\nvoid bigintLshiftByOne(inout float a[BYTE_COUNT]) {\n    bool negative = bigintRemoveTwosComplement(a);\n    biguintLshiftByOne(a);\n    bigintApplyTwosComplement(a, negative);\n}",declarations:["void bigintLshiftByOne(inout float [BYTE_COUNT]);"]},bigintMul:{source:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nbool bigintRemoveTwosComplement(inout float [BYTE_COUNT]);\nvoid biguintMul(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);\nvoid bigintApplyTwosComplement(inout float [BYTE_COUNT], bool);\nvoid bigintAssign(inout float [BYTE_COUNT], float);\n\nvoid bigintMul(float a[BYTE_COUNT], float b[BYTE_COUNT], inout float c[BYTE_COUNT]) {\n    bool aNegative = bigintRemoveTwosComplement(a);\n    bool bNegative = bigintRemoveTwosComplement(b);\n    biguintMul(a, b, c);\n    bigintApplyTwosComplement(c, aNegative != bNegative);\n}\n\nvoid bigintMul(float a[BYTE_COUNT], float bf, inout float c[BYTE_COUNT]) {\n    float b[BYTE_COUNT];\n    bigintAssign(b, bf);\n    bigintMul(a, b, c);\n}",declarations:["void bigintMul(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);","void bigintMul(float [BYTE_COUNT], float, inout float [BYTE_COUNT]);"]},bigintOr:{source:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nvoid biguintOr(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);\n\nvoid bigintOr(float a[BYTE_COUNT], float b[BYTE_COUNT], inout float c[BYTE_COUNT]) {\n    biguintOr(a, b, c);\n}",declarations:["void bigintOr(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);"]},bigintRemoveTwosComplement:{source:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nfloat gte(float, float);\n\nvoid biguintAdd(float [BYTE_COUNT], float, inout float [BYTE_COUNT]);\n\nbool bigintRemoveTwosComplement(inout float a[BYTE_COUNT]) {\n    float negative = gte(a[BYTE_COUNT-1], 128.0);\n    for (int i = 0; i < BYTE_COUNT; i++) {\n        a[i] = a[i] * (1.0 - negative)\n             + (255.0 - a[i]) * negative;\n    }\n    biguintAdd(a, negative, a);\n    return bool(negative);\n}",declarations:["bool bigintRemoveTwosComplement(inout float [BYTE_COUNT]);"]},bigintRshift:{source:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nbool bigintRemoveTwosComplement(inout float [BYTE_COUNT]);\nvoid biguintRshift(float [BYTE_COUNT], inout float [BYTE_COUNT], float);\nvoid bigintApplyTwosComplement(inout float [BYTE_COUNT], bool);\n\nvoid bigintRshift(float a[BYTE_COUNT], inout float b[BYTE_COUNT], float f) {\n    bool negative = bigintRemoveTwosComplement(a);\n    biguintRshift(a, b, f);\n    bigintApplyTwosComplement(b, negative);\n}",declarations:["void bigintRshift(float [BYTE_COUNT], inout float [BYTE_COUNT], float);"]},bigintRshiftByOne:{source:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nbool bigintRemoveTwosComplement(inout float [BYTE_COUNT]);\nvoid biguintRshiftByOne(float [BYTE_COUNT]);\nvoid bigintApplyTwosComplement(inout float [BYTE_COUNT], bool);\n\nvoid bigintRshiftByOne(inout float a[BYTE_COUNT]) {\n    bool negative = bigintRemoveTwosComplement(a);\n    biguintRshiftByOne(a);\n    bigintApplyTwosComplement(a, negative);\n}",declarations:["void bigintRshiftByOne(inout float [BYTE_COUNT]);"]},bigintSub:{source:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nvoid biguintSub(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);\nvoid bigintAssign(inout float [BYTE_COUNT], float);\n\nvoid bigintSub(float a[BYTE_COUNT], float b[BYTE_COUNT], inout float c[BYTE_COUNT]) {\n    biguintSub(a, b, c);\n}\n\nvoid bigintSub(float a[BYTE_COUNT], float bf, inout float c[BYTE_COUNT]) {\n    float b[BYTE_COUNT];\n    bigintAssign(b, bf);\n    bigintSub(a, b, c);\n}",declarations:["void bigintSub(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);","void bigintSub(float [BYTE_COUNT], float, inout float [BYTE_COUNT]);"]},bigintXor:{source:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nvoid biguintXor(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);\n\nvoid bigintXor(float a[BYTE_COUNT], float b[BYTE_COUNT], inout float c[BYTE_COUNT]) {\n    biguintXor(a, b, c);\n}",declarations:["void bigintXor(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);"]}})),t.rendered=T.render(t.dependencies,l.commonStutters)},function(n,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.RenderTarget=void 0;const e=i(1),o=i(15),a=i(8);class f{constructor(n,t){const i=e.getMaxRenderBufferSize();if(!Number.isInteger(n)||n<1||n>i)throw new Error(`ComputeTarget width of '${n}' is out of range (1 to ${i})`);if(Math.log(n)/Math.log(2)%1!=0)throw new Error(`ComputeTarget width of '${n}' is not a power of two`);this.width=n,this.targetAlpha=t||this.createTarget()}compute(n,t){const i=e.getWebGLContext();return i.useProgram(n.program),this.setBuffers(n,a.getComputeBufferInfo()),t&&this.setUniforms(n,t),i.bindFramebuffer(i.FRAMEBUFFER,this.targetAlpha.framebuffer),i.viewport(0,0,this.width,this.width),i.drawArrays(i.TRIANGLES,0,6),this}transpose(n){if(n.width!==this.width)throw new Error(`scatterFragCoord width: '${n.width}' != RenderTarget width: '${this.width}'`);const t=e.getWebGLContext(),i=o.getTransposeShader();return t.useProgram(i.program),this.setBuffers(i,o.getTransposeBufferInfo(this.width)),this.setUniforms(i,{u_scatterCoord:n,u_sourceTex:this,u_textureWidth:this.width}),t.bindFramebuffer(t.FRAMEBUFFER,this.targetAlpha.framebuffer),t.viewport(0,0,this.width,this.width),t.drawArrays(t.POINTS,0,this.width*this.width),this}pushSomePixels(n,t,i,o,a){if(a.length!==i*o*4)throw new Error("out.length !== "+i*o*4);const f=e.getWebGLContext();f.bindTexture(f.TEXTURE_2D,this.targetAlpha.texture),f.texSubImage2D(f.TEXTURE_2D,0,n,t,i,o,f.RGBA,f.UNSIGNED_BYTE,a),f.bindTexture(f.TEXTURE_2D,null)}pushPixelsRecursively(n,t,i,e,o,a,f){const r=Math.min(Math.max(Math.floor(o/i),1),e);if(this.pushSomePixels(n,t,i,r,a.subarray(0,4*i*r)),e-r<=0)return f();requestAnimationFrame(()=>this.pushPixelsRecursively(n,t+r,i,e-r,o,a.subarray(4*i*r),f))}pushSomePixelsAsync(n,t,i,e,o){return new Promise((a,f)=>{if(o.length!==i*e*4)return f(new Error("out.length !== "+i*e*4));this.pushPixelsRecursively(n,t,i,e,262144,o,()=>a())})}pushTextureData(n){const t=this.width,i=n.length/4,e=4*(i-i%t);if(n.length>4*t*t)throw new Error(`array length of: '${n.length}' overflows: '${4*t*t}'`);if(n.length%4>0)throw new Error(`array length of: '${n.length}' is not a multiple of four`);if(t>=i)return this.pushSomePixels(0,0,Math.min(i,t),Math.max(Math.floor(i/t),1),n);this.pushSomePixels(0,0,Math.min(i,t),Math.max(Math.floor(i/t),1),n.subarray(0,e)),4*t*t>n.length&&this.pushSomePixels(0,Math.floor(i/t),i%t,1,n.subarray(e))}pushTextureDataAsync(n){return new Promise((t,i)=>{const e=this.width,o=n.length/4,a=4*(o-o%e);return n.length>4*e*e?i(new Error(`array length of: '${n.length}' overflows: '${4*e*e}'`)):n.length%4>0?i(new Error(`array length of: '${n.length}' is not a multiple of four`)):void(e>=o?this.pushSomePixelsAsync(0,0,Math.min(o,e),Math.max(Math.floor(o/e),1),n).then(()=>t()).catch(n=>i(n)):4*e*e>n.length?this.pushSomePixelsAsync(0,0,Math.min(o,e),Math.max(Math.floor(o/e),1),n.subarray(0,a)).then(()=>this.pushSomePixelsAsync(0,Math.floor(o/this.width),o%this.width,1,n.subarray(a)).then(()=>t()).catch(n=>i(n))).catch(n=>i(n)):this.pushSomePixelsAsync(0,0,Math.min(o,e),Math.max(Math.floor(o/e),1),n.subarray(0,a)).then(()=>t()).catch(n=>i(n)))})}readPixels(n){return this.readSomePixels(0,0,this.width,this.width,n)}readPixelsAsync(n){return this.readSomePixelsAsync(0,0,this.width,this.width,n)}readSomePixels(n,t,i,o,a){a||(a=new Uint8Array(i*o*4));const f=e.getWebGLContext();return f.bindFramebuffer(f.FRAMEBUFFER,this.targetAlpha.framebuffer),f.readPixels(n,t,i,o,f.RGBA,f.UNSIGNED_BYTE,a),f.bindFramebuffer(f.FRAMEBUFFER,null),a}readPixelsRecursively(n,t,i,e,o,a,f){const r=Math.min(Math.max(Math.floor(o/i),1),e);if(this.readSomePixels(n,t,i,r,a.subarray(0,4*i*r)),e-r<=0)return f();requestAnimationFrame(()=>this.readPixelsRecursively(n,t+r,i,e-r,o,a.subarray(4*i*r),f))}readSomePixelsAsync(n,t,i,e,o){return new Promise((a,f)=>{if(o||(o=new Uint8Array(i*e*4)),o.length!==i*e*4)return f(new Error("out.length !== "+i*e*4));this.readPixelsRecursively(n,t,i,e,262144,o,()=>a(o))})}delete(){const n=e.getWebGLContext();n.deleteTexture(this.targetAlpha.texture),n.deleteFramebuffer(this.targetAlpha.framebuffer),this.targetBravo&&(n.deleteTexture(this.targetBravo.texture),n.deleteFramebuffer(this.targetBravo.framebuffer))}getBackbuffer(){return this.targetBravo?new f(this.width,this.targetBravo):null}deleteBackbuffer(){if(this.targetBravo){const n=e.getWebGLContext();n.deleteTexture(this.targetBravo.texture),n.deleteFramebuffer(this.targetBravo.framebuffer)}}setBuffers(n,t){const i=e.getWebGLContext();for(var o in t){const e=t[o].buffer,a=t[o].numComponents,f=n.attributeInfo[o].location;i.bindBuffer(i.ARRAY_BUFFER,e),i.enableVertexAttribArray(f),i.vertexAttribPointer(f,a,i.FLOAT,!1,0,0),i.bindBuffer(i.ARRAY_BUFFER,null)}}setUniforms(n,t){let i=0,o=!1;const a=e.getWebGLContext();for(let e in n.uniformInfo){if(void 0===t[e])continue;if(n.uniformInfo[e].type!==a.SAMPLER_2D)continue;const f=t[e];if(f.targetAlpha.texture===this.targetAlpha.texture&&(o||i++,o=!0),this.targetBravo&&this.targetBravo.texture===f.targetAlpha.texture)throw new Error(`provided uniform: '${e}' cannot be the RenderTarget's backbuffer`)}for(let e in n.uniformInfo){if(void 0===t[e])continue;const o=t[e],f=n.uniformInfo[e].type,r=n.uniformInfo[e].location;switch(f){case a.SAMPLER_2D:if(Array.isArray(o)||"number"==typeof o)throw new Error(`provided uniform: '${e}' is not a WebGLTexture`);a.uniform1i(r,i),a.activeTexture(a.TEXTURE0+i++),a.bindTexture(a.TEXTURE_2D,o.targetAlpha.texture);break;case a.FLOAT:"number"==typeof o?a.uniform1f(r,o):Array.isArray(o)&&a.uniform1fv(r,o);break;case a.FLOAT_VEC2:case a.FLOAT_VEC3:case a.FLOAT_VEC4:throw new Error("uniform vectors are currently unsupported");default:throw new Error(`unsupported uniform type: '${f}'`)}}o&&(this.targetBravo||(this.targetBravo=this.createTarget()),[this.targetAlpha,this.targetBravo]=[this.targetBravo,this.targetAlpha])}createTarget(){const n=e.getWebGLContext(),t=n.createFramebuffer();if(!t)throw new Error("unable to create framebuffer");const i=n.createTexture();if(!i)throw new Error("unable to create texture");return n.bindFramebuffer(n.FRAMEBUFFER,t),n.activeTexture(n.TEXTURE0),n.bindTexture(n.TEXTURE_2D,i),n.texImage2D(n.TEXTURE_2D,0,n.RGBA,this.width,this.width,0,n.RGBA,n.UNSIGNED_BYTE,null),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MAG_FILTER,n.NEAREST),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MIN_FILTER,n.NEAREST),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,i,0),n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),{framebuffer:t,texture:i}}}t.RenderTarget=f},function(n,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getComputeBufferInfo=t.createBufferInfoFromArrays=void 0;const e=i(1);function o(n){const t=e.getWebGLContext(),i={};for(let e in n){const o=t.createBuffer();if(null===o)throw new Error("unable to create buffer");i[e]={buffer:o,numComponents:n[e].numComponents}}for(let e in i)t.bindBuffer(t.ARRAY_BUFFER,i[e].buffer),t.bufferData(t.ARRAY_BUFFER,n[e].data,t.STATIC_DRAW);return t.bindBuffer(t.ARRAY_BUFFER,null),i}var a;t.createBufferInfoFromArrays=o,t.getComputeBufferInfo=function(){return a||(a=o({a_position:{data:new Float32Array([-1,-1,1,-1,-1,1,-1,1,1,-1,1,1]),numComponents:2}})),a}},function(n,t,i){"use strict";function e(n){for(let t=0;t<n.length;t++)n[t]=255-n[t]}function o(n){let t=1;for(let i=0;i<n.length;i++){let e=n[i]+t;e<=255&&(t=0),n[i]=e%256}}Object.defineProperty(t,"__esModule",{value:!0}),t.resizeBytes=t.hexToBytes=t.bytesToHex=t.removeTwosComplement=t.applyTwosComplement=t.addOne=t.flipBits=void 0,t.flipBits=e,t.addOne=o,t.applyTwosComplement=function(n,t){n[n.length-1]>=128&&(n[n.length-1]-=128),t&&(e(n),o(n))},t.removeTwosComplement=function(n){const t=n[n.length-1]>=128;return t&&(e(n),o(n)),t};const a=Array.from(Array(16),(n,t)=>t.toString(16));t.bytesToHex=function(n){let t="";for(let i=n.length-1;i>=0;i--){const e=n[i];t+=a[Math.floor(e/16)],t+=a[e%16]}return t};const f={};a.forEach((n,t)=>f[n]=t),t.hexToBytes=function(n){n.length%2&&(n="0"+n);const t=new Uint8Array(n.length/2);for(let i=0;i<t.length;i++){const e=16*f[n[2*i]],o=f[n[2*i+1]];t[t.length-i-1]=e+o}return t},t.resizeBytes=function(n,t,i){return n.length===t?n:n.length>t?i?n.subarray(n.length-t):n.subarray(0,t):i?new Uint8Array([...Array(t-n.length).fill(0),...n]):new Uint8Array([...n,...Array(t-n.length).fill(0)])}},function(n,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.packBooleans=t.unpackBooleans=void 0,t.unpackBooleans=function(n){var t=new Array(8);n=Math.min(Math.max(0,Math.round(n)),255);for(var i=0;i<8;i++){var e=Math.pow(2,7-i);n>=e?(t[i]=!0,n-=e):t[i]=!1}return t},t.packBooleans=function(n){for(var t=0,i=0;i<8;i++)n.length>i&&n[i]&&(t+=Math.pow(2,7-i));return t}},function(n,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.packInt16=t.unpackInt16=t.MIN_INT16=t.MAX_INT16=void 0,t.MAX_INT16=32768,t.MIN_INT16=-32767,t.unpackInt16=function(n,t){return 256*(n=Math.min(Math.max(0,Math.floor(n)),255))+(t=Math.min(Math.max(0,Math.floor(t)),255))-32767},t.packInt16=function(n){var t=new Array(2);return n=Math.min(Math.max(-32767,Math.round(n)),32768)+32767,t[0]=Math.floor(n/256),t[1]=n-256*t[0],t}},function(n,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.packUint16=t.unpackUint16=t.MIN_UINT16=t.MAX_UINT16=void 0,t.MAX_UINT16=65535,t.MIN_UINT16=0,t.unpackUint16=function(n,t){return 256*(n=Math.min(Math.max(0,Math.floor(n)),255))+(t=Math.min(Math.max(0,Math.floor(t)),255))},t.packUint16=function(n){var t=new Array(2);return n=Math.min(Math.max(0,Math.round(n)),65535),t[0]=Math.floor(n/256),t[1]=n-256*t[0],t}},function(n,t,i){"use strict";var e=this&&this.__createBinding||(Object.create?function(n,t,i,e){void 0===e&&(e=i),Object.defineProperty(n,e,{enumerable:!0,get:function(){return t[i]}})}:function(n,t,i,e){void 0===e&&(e=i),n[e]=t[i]}),o=this&&this.__setModuleDefault||(Object.create?function(n,t){Object.defineProperty(n,"default",{enumerable:!0,value:t})}:function(n,t){n.default=t}),a=this&&this.__importStar||function(n){if(n&&n.__esModule)return n;var t={};if(null!=n)for(var i in n)Object.hasOwnProperty.call(n,i)&&e(t,n,i);return o(t,n),t},f=this&&this.__awaiter||function(n,t,i,e){return new(i||(i=Promise))((function(o,a){function f(n){try{l(e.next(n))}catch(n){a(n)}}function r(n){try{l(e.throw(n))}catch(n){a(n)}}function l(n){var t;n.done?o(n.value):(t=n.value,t instanceof i?t:new i((function(n){n(t)}))).then(f,r)}l((e=e.apply(n,t||[])).next())}))};Object.defineProperty(t,"__esModule",{value:!0}),t.getWebGLContext=t.getBenchmarkText=t.startBenchmarking=t.isBenchmarking=void 0;const r=a(i(14)),l=i(0);let T=!1,s="PENDING!";function u(){return T}t.isBenchmarking=u;function g(){return f(this,void 0,void 0,(function*(){T||(T=!0,s="EXECUTING FOO",setTimeout(()=>{var n;T=!1,n="#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nvoid biguintAdd(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);\nvoid bigintAssign(inout float [BYTE_COUNT], float);\n\nvoid bigintAdd(float a[BYTE_COUNT], float b[BYTE_COUNT], inout float c[BYTE_COUNT]) {\n    biguintAdd(a, b, c);\n}\n\nvoid bigintAdd(float a[BYTE_COUNT], float bf, inout float c[BYTE_COUNT]) {\n    float b[BYTE_COUNT];\n    bigintAssign(b, bf);\n    bigintAdd(a, b, c);\n}",s=l.replaceDependencies(n.replace(/\r+/gm,"").replace(/\t/g,"    ").replace(/\n{3,}/g,"\n\n"))},2500))}))}function d(){return s}function b(){return r.getWebGLContext()}t.startBenchmarking=g,t.getBenchmarkText=d,t.getWebGLContext=b,t.default={startBenchmarking:g,getBenchmarkText:d,isBenchmarking:u,getWebGLContext:b}},function(n,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const e=i(1),o=i(4),a=i(7),f=i(10),r=i(11),l=i(12),T=i(0),s=i(3),u=i(6);n.exports={setWebGLContext:e.setWebGLContext,getWebGLContext:e.getWebGLContext,isWebGL2:e.isWebGL2,ComputeShader:o.ComputeShader,passThruFrag:o.passThruFrag,passThruVert:o.passThruVert,RenderTarget:a.RenderTarget,packBooleans:f.packBooleans,unpackBooleans:f.unpackBooleans,packInt16:r.packInt16,unpackInt16:r.unpackInt16,MIN_INT16:r.MIN_INT16,MAX_INT16:r.MAX_INT16,packUint16:l.packUint16,unpackUint16:l.unpackUint16,MIN_UINT16:l.MIN_UINT16,MAX_UINT16:l.MAX_UINT16,functionStrings:T.functionStrings,replaceDependencies:T.replaceDependencies,decodeUnsignedBytes:s.decodeUnsignedBytes,encodeUnsignedBytes:s.encodeUnsignedBytes,decodeSignedBytes:u.decodeSignedBytes,encodeSignedBytes:u.encodeSignedBytes};var g=i(1);Object.defineProperty(t,"setWebGLContext",{enumerable:!0,get:function(){return g.setWebGLContext}}),Object.defineProperty(t,"getWebGLContext",{enumerable:!0,get:function(){return g.getWebGLContext}}),Object.defineProperty(t,"isWebGL2",{enumerable:!0,get:function(){return g.isWebGL2}});var d=i(4);Object.defineProperty(t,"ComputeShader",{enumerable:!0,get:function(){return d.ComputeShader}}),Object.defineProperty(t,"passThruFrag",{enumerable:!0,get:function(){return d.passThruFrag}}),Object.defineProperty(t,"passThruVert",{enumerable:!0,get:function(){return d.passThruVert}});var b=i(7);Object.defineProperty(t,"RenderTarget",{enumerable:!0,get:function(){return b.RenderTarget}});var c=i(10);Object.defineProperty(t,"packBooleans",{enumerable:!0,get:function(){return c.packBooleans}}),Object.defineProperty(t,"unpackBooleans",{enumerable:!0,get:function(){return c.unpackBooleans}});var E=i(11);Object.defineProperty(t,"packInt16",{enumerable:!0,get:function(){return E.packInt16}}),Object.defineProperty(t,"unpackInt16",{enumerable:!0,get:function(){return E.unpackInt16}}),Object.defineProperty(t,"MIN_INT16",{enumerable:!0,get:function(){return E.MIN_INT16}}),Object.defineProperty(t,"MAX_INT16",{enumerable:!0,get:function(){return E.MAX_INT16}});var _=i(12);Object.defineProperty(t,"packUint16",{enumerable:!0,get:function(){return _.packUint16}}),Object.defineProperty(t,"unpackUint16",{enumerable:!0,get:function(){return _.unpackUint16}}),Object.defineProperty(t,"MIN_UINT16",{enumerable:!0,get:function(){return _.MIN_UINT16}}),Object.defineProperty(t,"MAX_UINT16",{enumerable:!0,get:function(){return _.MAX_UINT16}});var h=i(0);Object.defineProperty(t,"functionStrings",{enumerable:!0,get:function(){return h.functionStrings}}),Object.defineProperty(t,"replaceDependencies",{enumerable:!0,get:function(){return h.replaceDependencies}});var B=i(3);Object.defineProperty(t,"decodeUnsignedBytes",{enumerable:!0,get:function(){return B.decodeUnsignedBytes}}),Object.defineProperty(t,"encodeUnsignedBytes",{enumerable:!0,get:function(){return B.encodeUnsignedBytes}});var p=i(6);Object.defineProperty(t,"decodeSignedBytes",{enumerable:!0,get:function(){return p.decodeSignedBytes}}),Object.defineProperty(t,"encodeSignedBytes",{enumerable:!0,get:function(){return p.encodeSignedBytes}})},function(n,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getTransposeShader=t.getTransposeBufferInfo=t.passThruTransposeFrag=t.passThruTransposeVert=void 0;const e=i(1),o=i(8),a=i(4),f=i(0);t.passThruTransposeVert=`\n#ifdef GL_ES\nprecision mediump float;\nprecision mediump int;\nprecision mediump sampler2D;\n#endif\n\nuniform sampler2D u_scatterCoord;\nuniform sampler2D u_sourceTex;\nuniform float u_textureWidth;\nattribute vec2 a_position;\nvarying vec4 v_sourceTexel;\n\n${f.functionStrings.uint16FromVec2}\n\nvoid main() {\n  gl_PointSize = 1.0;\n  vec4 destinationTexel = texture2D(u_scatterCoord, vec2(a_position.x + 1.0, a_position.y + 1.0) / 2.0);\n  vec2 destinationCoord = vec2(uint16FromVec2(destinationTexel.rg) + 0.5, uint16FromVec2(destinationTexel.ba) + 0.5);\n  gl_Position = vec4(2.0 * (destinationCoord.xy / u_textureWidth) - vec2(1.0, 1.0), 0.0, 1.0);\n  v_sourceTexel = texture2D(u_sourceTex, vec2(a_position.x + 1.0, a_position.y + 1.0) / 2.0);\n}`,t.passThruTransposeFrag="\n#ifdef GL_ES\nprecision mediump float;\nprecision mediump int;\nprecision mediump sampler2D;\n#endif\n\nvarying vec4 v_sourceTexel;\n\nvoid main() {\n  gl_FragColor = v_sourceTexel;\n}";const r=new Array(13);var l;t.getTransposeBufferInfo=function(n){if(n<2||n>4096)throw new Error(`width of '${n}' is out of range (2 to 4096)`);const t=Math.log(n)/Math.log(2);if(t%1!=0)throw new Error(`width of '${n}' is not a power of two`);if(!r[t]){const n=Math.pow(2,t),f=new Float32Array(2*n*n);for(var i=0,e=0;e<n;e++)for(var a=0;a<n;a++)f[i++]=2*(a+.5)/n-1,f[i++]=2*(e+.5)/n-1;const l=o.createBufferInfoFromArrays({a_position:{data:f,numComponents:2}});r[t]=l}return r[t]},t.getTransposeShader=function(){if(l)return l;const n=e.getWebGLContext(),i=n.getParameter(n.MAX_VERTEX_TEXTURE_IMAGE_UNITS);if(i<2)throw new Error(`MAX_VERTEX_TEXTURE_IMAGE_UNITS: '${i}' is less than 2`);return l=new a.ComputeShader(t.passThruTransposeFrag,void 0,t.passThruTransposeVert)}}]);