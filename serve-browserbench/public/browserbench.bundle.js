window.browserbench=function(n){var t={};function i(e){if(t[e])return t[e].exports;var o=t[e]={i:e,l:!1,exports:{}};return n[e].call(o.exports,o,o.exports,i),o.l=!0,o.exports}return i.m=n,i.c=t,i.d=function(n,t,e){i.o(n,t)||Object.defineProperty(n,t,{enumerable:!0,get:e})},i.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},i.t=function(n,t){if(1&t&&(n=i(n)),8&t)return n;if(4&t&&"object"==typeof n&&n&&n.__esModule)return n;var e=Object.create(null);if(i.r(e),Object.defineProperty(e,"default",{enumerable:!0,value:n}),2&t&&"string"!=typeof n)for(var o in n)i.d(e,o,function(t){return n[t]}.bind(null,o));return e},i.n=function(n){var t=n&&n.__esModule?function(){return n.default}:function(){return n};return i.d(t,"a",t),t},i.o=function(n,t){return Object.prototype.hasOwnProperty.call(n,t)},i.p="",i(i.s=7)}([function(n,t,i){"use strict";var e;function o(){if(!e)try{const n=document.createElement("canvas");if(!n)throw new Error("unable to create canvas");const t=n.getContext("webgl2");if(t&&"undefined"!=typeof WebGL2RenderingContext)console.debug("your browser supports WebGL2"),e=t;else{console.debug("your browser doesn't support WebGL2");const t=n.getContext("webgl");if(!t)throw new Error("unable to get context");e=t}}catch(n){throw new Error("unable to get WebGL context from canvas")}return e}Object.defineProperty(t,"__esModule",{value:!0}),t.getWebGLContext=o,t.setWebGLContext=function(n){return e=n||o()},t.isWebGL2=function(){return"undefined"!=typeof WebGL2RenderingContext&&o()instanceof WebGL2RenderingContext},t.getMaxRenderBufferSize=function(){if(!r){const n=o();r=n.getParameter(n.MAX_RENDERBUFFER_SIZE)}return r};var r=0},function(n,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.ComputeShader=t.passThruFrag=t.passThruVert=void 0;var e=i(0);function o(n,t,i){return t in n?Object.defineProperty(n,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):n[t]=i,n}const r="\n#ifdef GL_ES\nprecision mediump float;\nprecision mediump int;\nprecision mediump sampler2D;\n#endif\n\nattribute vec3 a_position;\n\nvoid main() {\n  gl_Position = vec4(a_position, 1.0);\n}";t.passThruVert=r;t.passThruFrag="\n#ifdef GL_ES\nprecision mediump float;\nprecision mediump int;\nprecision mediump sampler2D;\n#endif\n\nuniform sampler2D u_tex;\nuniform float u_textureWidth;\n\nvoid main() {\n  gl_FragColor = texture2D(u_tex, gl_FragCoord.xy / u_textureWidth);\n}";t.ComputeShader=class{constructor(n,t,i,a){o(this,"program",void 0),o(this,"vertShader",void 0),o(this,"fragShader",void 0),o(this,"attributeInfo",void 0),o(this,"uniformInfo",void 0),a=a?(0,e.setWebGLContext)(a):(0,e.getWebGLContext)(),this.vertShader=this.createVertShader(this.searchAndReplace(i||r,t)),this.fragShader=this.createFragShader(this.searchAndReplace(n,t)),this.program=this.createProgram(this.vertShader,this.fragShader),this.attributeInfo=this.getAttributeInfo(a,this.program),this.uniformInfo=this.getUniformInfo(a,this.program)}delete(){const n=(0,e.getWebGLContext)();n.deleteShader(this.vertShader),n.deleteShader(this.fragShader),n.deleteProgram(this.program)}preprocess(n){return(n=(n=(n=n.replace(/\t/g,"    ")).replace(/\r+/gm,"")).replace(/\n{3,}/g,"\n\n")).trim()}createVertShader(n){const t=(0,e.getWebGLContext)(),i=t.createShader(t.VERTEX_SHADER);if(!i)throw new Error("unable to create new vertex shader");if(t.shaderSource(i,this.preprocess(n)),t.compileShader(i),!t.getShaderParameter(i,t.COMPILE_STATUS))throw new Error(`could not compile vertex shader: ${t.getShaderInfoLog(i)}\n\n${n.trim()}`);return i}createFragShader(n){const t=(0,e.getWebGLContext)(),i=t.createShader(t.FRAGMENT_SHADER);if(!i)throw new Error("unable to create new fragment shader");if(t.shaderSource(i,this.preprocess(n)),t.compileShader(i),!t.getShaderParameter(i,t.COMPILE_STATUS))throw new Error(`could not compile fragment shader: ${t.getShaderInfoLog(i)}\n\n${n.trim()}`);return i}createProgram(n,t){const i=(0,e.getWebGLContext)();var o=i.createProgram();if(!o)throw new Error("unable to create program");if(i.attachShader(o,n),i.attachShader(o,t),i.linkProgram(o),!i.getProgramParameter(o,i.LINK_STATUS))throw new Error("error in program linking: "+i.getProgramInfoLog(o));return o}searchAndReplace(n,t){if(t)for(var[i,e]of Object.entries(t))n=n.replace(i,e);return n}getAttributeInfo(n,t){const i={},e=n.getProgramParameter(t,n.ACTIVE_ATTRIBUTES);for(let o=0;o<e;o++){const e=n.getActiveAttrib(t,o);if(null===e)continue;const r=n.getAttribLocation(t,e.name);null!==r&&(i[e.name]={size:e.size,type:e.type,location:r})}return i}getUniformInfo(n,t){const i={},e=n.getProgramParameter(t,n.ACTIVE_UNIFORMS);for(let o=0;o<e;o++){const e=n.getActiveUniform(t,o);if(null===e)continue;const r=n.getUniformLocation(t,e.name);null!==r&&(i[e.name]={size:e.size,type:e.type,location:r})}return i}}},function(n,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.createBufferInfoFromArrays=r,t.getComputeBufferInfo=function(){e||(e=r({a_position:{data:new Float32Array([-1,-1,1,-1,-1,1,-1,1,1,-1,1,1]),numComponents:2}}));return e};var e,o=i(0);function r(n){const t=(0,o.getWebGLContext)(),i={};for(let e in n){const o=t.createBuffer();if(null===o)throw new Error("unable to create buffer");i[e]={buffer:o,numComponents:n[e].numComponents}}for(let e in i)t.bindBuffer(t.ARRAY_BUFFER,i[e].buffer),t.bufferData(t.ARRAY_BUFFER,n[e].data,t.STATIC_DRAW);return t.bindBuffer(t.ARRAY_BUFFER,null),i}},function(n,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.expandDefinitions=function(n){return e.expandDefinitions(n)},t.functionStrings=void 0;var e=function(n){if(n&&n.__esModule)return n;if(null===n||"object"!=typeof n&&"function"!=typeof n)return{default:n};var t=o();if(t&&t.has(n))return t.get(n);var i={},e=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var r in n)if(Object.prototype.hasOwnProperty.call(n,r)){var a=e?Object.getOwnPropertyDescriptor(n,r):null;a&&(a.get||a.set)?Object.defineProperty(i,r,a):i[r]=n[r]}i.default=n,t&&t.set(n,i);return i}(i(4));function o(){if("function"!=typeof WeakMap)return null;var n=new WeakMap;return o=function(){return n},n}const r={round:"\nfloat round(float f) {\n  return floor(f + 0.5);\n}".trim(),vec2ToInt16:"\nfloat vec2ToInt16(vec2 v) {\n  return clamp(floor(floor(v.r * 255.0) * 256.0) + floor(v.g * 255.0) - 32767.0, -32767.0, 32768.0);\n}".trim(),int16ToVec2:"\nvec2 int16ToVec2(float f) {\n  f = clamp(f, -32767.0, 32768.0) + 32767.0; \n  return vec2(floor(f / 256.0), f - floor(f / 256.0) * 256.0) / 255.0; \n}".trim(),vec2ToUint16:"\nfloat vec2ToUint16(vec2 v) {\n  return clamp(floor(floor(v.r * 255.0) * 256.0) + floor(v.g * 255.0), 0.0, 65535.0);\n}".trim(),uint16ToVec2:"\nvec2 uint16ToVec2(float f) {\n  f = clamp(f, 0.0, 65535.0); \n  return vec2(floor(f / 256.0), f - floor(f / 256.0) * 256.0) / 255.0; \n}".trim(),unpackBooleans:"\nvoid unpackBooleans(float f, inout bool arr[8]) {\n  f = floor(f * 255.0);\n  arr[0] = bool(int(1.0 - max(sign(128.0 - f), 0.0)));  \n  f -= (1.0 - max(sign(128.0 - f), 0.0)) * 128.0;\n  arr[1] = bool(int(1.0 - max(sign(64.0 - f), 0.0)));\n  f -= (1.0 - max(sign(64.0 - f), 0.0)) * 64.0;\n  arr[2] = bool(int(1.0 - max(sign(32.0 - f), 0.0)));\n  f -= (1.0 - max(sign(32.0 - f), 0.0)) * 32.0;\n  arr[3] = bool(int(1.0 - max(sign(16.0 - f), 0.0)));\n  f -= (1.0 - max(sign(16.0 - f), 0.0)) * 16.0;\n  arr[4] = bool(int(1.0 - max(sign(8.0 - f), 0.0)));\n  f -= (1.0 - max(sign(8.0 - f), 0.0)) * 8.0;\n  arr[5] = bool(int(1.0 - max(sign(4.0 - f), 0.0)));\n  f -= (1.0 - max(sign(4.0 - f), 0.0)) * 4.0;\n  arr[6] = bool(int(1.0 - max(sign(2.0 - f), 0.0)));\n  f -= (1.0 - max(sign(2.0 - f), 0.0)) * 2.0;\n  arr[7] = bool(int(1.0 - max(sign(1.0 - f), 0.0)));\n}".trim(),packBooleans:"\nfloat packBooleans(bool arr[8]) {\n  float f = float(int(arr[0])) * 128.0;\n  f += float(int(arr[1])) * 64.0;\n  f += float(int(arr[2])) * 32.0;\n  f += float(int(arr[3])) * 16.0;\n  f += float(int(arr[4])) * 8.0;\n  f += float(int(arr[5])) * 4.0;\n  f += float(int(arr[6])) * 2.0;\n  return (f + float(int(arr[7]))) / 255.0;\n}".trim()};t.functionStrings=r},function(n,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.decodeSignedBytes=function(n,t){const i=(0,r.removeTwosComplement)(n);t&&n.reverse();const e=BigInt("0x"+(0,r.bytesToHex)(n))*(i?BigInt(-1):BigInt(1));return(0,r.applyTwosComplement)(n,i),e},t.encodeSignedBytes=function(n,t,i){const e=n<BigInt(0);e&&(n*=BigInt(-1));const o=(0,r.resizeBytes)((0,r.hexToBytes)(n.toString(16)),t,i);(0,r.applyTwosComplement)(o,e),i&&o.reverse();return o},t.expandDefinitions=function(n){return n=(0,o.replaceDefinitions)(n,f,l),(0,o.removeStutters)(n,u).replace(/\n{3,}/g,"\n\n")},t.declarations=t.untouchedFunctionStrings=t.functionStrings=void 0;var e=function(n){if(n&&n.__esModule)return n;if(null===n||"object"!=typeof n&&"function"!=typeof n)return{default:n};var t=a();if(t&&t.has(n))return t.get(n);var i={},e=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in n)if(Object.prototype.hasOwnProperty.call(n,o)){var r=e?Object.getOwnPropertyDescriptor(n,o):null;r&&(r.get||r.set)?Object.defineProperty(i,o,r):i[o]=n[o]}i.default=n,t&&t.set(n,i);return i}(i(11)),o=i(6),r=i(5);function a(){if("function"!=typeof WeakMap)return null;var n=new WeakMap;return a=function(){return n},n}const f={bigintAbs:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nbool bigintRemoveTwosComplement(inout float [BYTE_COUNT]);\nvoid bigintApplyTwosComplement(inout float [BYTE_COUNT], bool);\n\nvoid bigintAbs(inout float a[BYTE_COUNT]) {\n    bigintRemoveTwosComplement(a);\n    bigintApplyTwosComplement(a, false);\n}",bigintAdd:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nvoid biguintAdd(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);\nvoid bigintAssign(inout float [BYTE_COUNT], float);\n\nvoid bigintAdd(float a[BYTE_COUNT], float b[BYTE_COUNT], inout float c[BYTE_COUNT]) {\n    biguintAdd(a, b, c);\n}\n\nvoid bigintAdd(float a[BYTE_COUNT], float bf, inout float c[BYTE_COUNT]) {\n    float b[BYTE_COUNT];\n    bigintAssign(b, bf);\n    bigintAdd(a, b, c);\n}",bigintAnd:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nvoid biguintAnd(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);\n\nvoid bigintAnd(float a[BYTE_COUNT], float b[BYTE_COUNT], inout float c[BYTE_COUNT]) {\n    biguintAnd(a, b, c);\n}",bigintApplyTwosComplement:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nvoid biguintAdd(float [BYTE_COUNT], float, inout float [BYTE_COUNT]);\n\nvoid bigintApplyTwosComplement(inout float a[BYTE_COUNT], float negative) {\n    a[BYTE_COUNT-1] -= float(a[BYTE_COUNT-1] >= 128.0) * 128.0;\n    for (int i = 0; i < BYTE_COUNT; i++) {\n        a[i] = a[i] * (1.0 - negative)\n             + (255.0 - a[i]) * negative;\n    }\n    biguintAdd(a, negative, a);\n}\n\nvoid bigintApplyTwosComplement(inout float a[BYTE_COUNT], bool negative) {\n    bigintApplyTwosComplement(a, float(negative));\n}",bigintAssign:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nvoid bigintApplyTwosComplement(inout float [BYTE_COUNT], float);\n\nvoid bigintAssign(inout float dst[BYTE_COUNT], float src[BYTE_COUNT]) {\n    for (int i = 0; i < BYTE_COUNT; i++) dst[i] = src[i];\n}\n\nvoid bigintAssign(inout float dst[BYTE_COUNT], float f) {\n    float isNegative = float(f < 0.0);\n    f = min(abs(floor(f)), 65535.0);\n    dst[0] = mod(f, 256.0);\n    dst[1] = floor(f / 256.0);\n    for (int i = 2; i < BYTE_COUNT; i++) dst[i] = 0.0;\n    bigintApplyTwosComplement(dst, isNegative);\n}",bigintAssignIfTrue:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nvoid bigintAssign(inout float [BYTE_COUNT], float);\n\nvoid bigintAssignIfTrue(inout float dst[BYTE_COUNT], float src[BYTE_COUNT], float f) {\n    for (int i = 0; i < BYTE_COUNT; i++)\n       dst[i] = src[i] * float(f != 0.0)\n              + dst[i] * float(f == 0.0);\n}\n\nvoid bigintAssignIfTrue(inout float dst[BYTE_COUNT], float src[BYTE_COUNT], bool b) {\n    bigintAssignIfTrue(dst, src, float(b));\n}\n\nvoid bigintAssignIfTrue(inout float dst[BYTE_COUNT], float sf, float f) {\n    float src[BYTE_COUNT];\n    bigintAssign(dst, sf);\n    bigintAssignIfTrue(dst, src, f);\n}\n\nvoid bigintAssignIfTrue(inout float dst[BYTE_COUNT], float sf, bool b) {\n    float src[BYTE_COUNT];\n    bigintAssign(dst, sf);\n    bigintAssignIfTrue(dst, src, float(b));\n}",bigintDiv:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nbool bigintRemoveTwosComplement(inout float [BYTE_COUNT]);\nvoid biguintDiv(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);\nvoid bigintApplyTwosComplement(inout float [BYTE_COUNT], bool);\nvoid bigintAssign(inout float [BYTE_COUNT], float);\n\nvoid bigintDiv(float a[BYTE_COUNT], float b[BYTE_COUNT], inout float c[BYTE_COUNT]) {\n    bool aNegative = bigintRemoveTwosComplement(a);\n    bool bNegative = bigintRemoveTwosComplement(b);\n    biguintDiv(a, b, c);\n    bigintApplyTwosComplement(c, aNegative != bNegative);\n}\n\nvoid bigintDiv(float a[BYTE_COUNT], float bf, inout float c[BYTE_COUNT]) {\n    float b[BYTE_COUNT];\n    bigintAssign(b, bf);\n    bigintDiv(a, b, c);\n}",bigintEquals:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nbool bigintRemoveTwosComplement(inout float [BYTE_COUNT]);\nvoid bigintAssign(inout float [BYTE_COUNT], float);\n\nfloat bigintEquals(float a[BYTE_COUNT], float b[BYTE_COUNT]) {\n    float cmp;\n    bool aNegative = bigintRemoveTwosComplement(a);\n    bool bNegative = bigintRemoveTwosComplement(b);\n    cmp += float(aNegative == false && bNegative == true);\n    cmp -= float(aNegative == true && bNegative == false);\n    for (int i = BYTE_COUNT - 1; i >= 0; i--)\n        cmp += float(cmp == 0.0) * float(a[i] > b[i])\n             - float(cmp == 0.0) * float(a[i] < b[i]);\n    return float(cmp == 0.0);\n}\n\nfloat bigintEquals(float a[BYTE_COUNT], float bf) {\n    float b[BYTE_COUNT];\n    bigintAssign(b, bf);\n    return bigintEquals(a, b);\n}",bigintGreaterThan:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nbool bigintRemoveTwosComplement(inout float [BYTE_COUNT]);\nvoid bigintAssign(inout float [BYTE_COUNT], float);\n\nfloat bigintGreaterThan(float a[BYTE_COUNT], float b[BYTE_COUNT]) {\n    float cmp;\n    bool aNegative = bigintRemoveTwosComplement(a);\n    bool bNegative = bigintRemoveTwosComplement(b);\n    cmp += float(aNegative == false && bNegative == true);\n    cmp -= float(aNegative == true && bNegative == false);\n    for (int i = BYTE_COUNT - 1; i >= 0; i--) {\n        cmp += float(cmp == 0.0) * float(a[i] > b[i]);\n        cmp -= float(cmp == 0.0) * float(a[i] < b[i]);\n    }\n    return float(cmp > 0.0);\n}\n\nfloat bigintGreaterThan(float a[BYTE_COUNT], float bf) {\n    float b[BYTE_COUNT];\n    bigintAssign(b, bf);\n    return bigintGreaterThan(a, b);\n}",bigintGreaterThanOrEqual:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nbool bigintRemoveTwosComplement(inout float [BYTE_COUNT]);\nvoid bigintAssign(inout float [BYTE_COUNT], float);\n\nfloat bigintGreaterThanOrEqual(float a[BYTE_COUNT], float b[BYTE_COUNT]) {\n    float cmp;\n    bool aNegative = bigintRemoveTwosComplement(a);\n    bool bNegative = bigintRemoveTwosComplement(b);\n    cmp += float(aNegative == false && bNegative == true);\n    cmp -= float(aNegative == true && bNegative == false);\n    for (int i = BYTE_COUNT - 1; i >= 0; i--) {\n        cmp += float(cmp == 0.0) * float(a[i] > b[i]);\n        cmp -= float(cmp == 0.0) * float(a[i] < b[i]);\n    }\n    return float(cmp >= 0.0);\n}\n\nfloat bigintGreaterThanOrEqual(float a[BYTE_COUNT], float bf) {\n    float b[BYTE_COUNT];\n    bigintAssign(b, bf);\n    return bigintGreaterThanOrEqual(a, b);\n}",bigintLessThan:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nbool bigintRemoveTwosComplement(inout float [BYTE_COUNT]);\nvoid bigintAssign(inout float [BYTE_COUNT], float);\n\nfloat bigintLessThan(float a[BYTE_COUNT], float b[BYTE_COUNT]) {\n    float cmp;\n    bool aNegative = bigintRemoveTwosComplement(a);\n    bool bNegative = bigintRemoveTwosComplement(b);\n    cmp += float(aNegative == false && bNegative == true);\n    cmp -= float(aNegative == true && bNegative == false);\n    for (int i = BYTE_COUNT - 1; i >= 0; i--) {\n        cmp += float(cmp == 0.0) * float(a[i] > b[i]);\n        cmp -= float(cmp == 0.0) * float(a[i] < b[i]);\n    }\n    return float(cmp < 0.0);\n}\n\nfloat bigintLessThan(float a[BYTE_COUNT], float bf) {\n    float b[BYTE_COUNT];\n    bigintAssign(b, bf);\n    return bigintLessThan(a, b);\n}\n",bigintLessThanOrEqual:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nbool bigintRemoveTwosComplement(inout float [BYTE_COUNT]);\nvoid bigintAssign(inout float [BYTE_COUNT], float);\n\nfloat bigintLessThanOrEqual(float a[BYTE_COUNT], float b[BYTE_COUNT]) {\n    float cmp;\n    bool aNegative = bigintRemoveTwosComplement(a);\n    bool bNegative = bigintRemoveTwosComplement(b);\n    cmp += float(aNegative == false && bNegative == true);\n    cmp -= float(aNegative == true && bNegative == false);\n    for (int i = BYTE_COUNT - 1; i >= 0; i--) {\n        cmp += float(cmp == 0.0) * float(a[i] > b[i]);\n        cmp -= float(cmp == 0.0) * float(a[i] < b[i]);\n    }\n    return float(cmp <= 0.0);\n}\n\nfloat bigintLessThanOrEqual(float a[BYTE_COUNT], float bf) {\n    float b[BYTE_COUNT];\n    bigintAssign(b, bf);\n    return bigintLessThanOrEqual(a, b);\n}",bigintLshift:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nbool bigintRemoveTwosComplement(inout float [BYTE_COUNT]);\nvoid biguintLshift(float [BYTE_COUNT], inout float [BYTE_COUNT], float);\nvoid bigintApplyTwosComplement(inout float [BYTE_COUNT], bool);\n\nvoid bigintLshift(float a[BYTE_COUNT], inout float b[BYTE_COUNT], float f) {\n    bool negative = bigintRemoveTwosComplement(a);\n    biguintLshift(a, b, f);\n    bigintApplyTwosComplement(b, negative);\n}",bigintLshiftByOne:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nbool bigintRemoveTwosComplement(inout float [BYTE_COUNT]);\nvoid biguintLshiftByOne(inout float [BYTE_COUNT]);\nvoid bigintApplyTwosComplement(inout float [BYTE_COUNT], bool);\n\nvoid bigintLshiftByOne(inout float a[BYTE_COUNT]) {\n    bool negative = bigintRemoveTwosComplement(a);\n    biguintLshiftByOne(a);\n    bigintApplyTwosComplement(a, negative);\n}",bigintMul:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nbool bigintRemoveTwosComplement(inout float [BYTE_COUNT]);\nvoid biguintMul(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);\nvoid bigintApplyTwosComplement(inout float [BYTE_COUNT], bool);\nvoid bigintAssign(inout float [BYTE_COUNT], float);\n\nvoid bigintMul(float a[BYTE_COUNT], float b[BYTE_COUNT], inout float c[BYTE_COUNT]) {\n    bool aNegative = bigintRemoveTwosComplement(a);\n    bool bNegative = bigintRemoveTwosComplement(b);\n    biguintMul(a, b, c);\n    bigintApplyTwosComplement(c, aNegative != bNegative);\n}\n\nvoid bigintMul(float a[BYTE_COUNT], float bf, inout float c[BYTE_COUNT]) {\n    float b[BYTE_COUNT];\n    bigintAssign(b, bf);\n    bigintMul(a, b, c);\n}",bigintOr:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nvoid biguintOr(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);\n\nvoid bigintOr(float a[BYTE_COUNT], float b[BYTE_COUNT], inout float c[BYTE_COUNT]) {\n    biguintOr(a, b, c);\n}",bigintRemoveTwosComplement:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nvoid biguintAdd(float [BYTE_COUNT], float, inout float [BYTE_COUNT]);\n\nbool bigintRemoveTwosComplement(inout float a[BYTE_COUNT]) {\n    float negative = float(a[BYTE_COUNT-1] >= 128.0);\n    for (int i = 0; i < BYTE_COUNT; i++) {\n        a[i] = a[i] * (1.0 - negative)\n             + (255.0 - a[i]) * negative;\n    }\n    biguintAdd(a, negative, a);\n    return bool(negative);\n}",bigintRshift:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nbool bigintRemoveTwosComplement(inout float [BYTE_COUNT]);\nvoid biguintRshift(float [BYTE_COUNT], inout float [BYTE_COUNT], float);\nvoid bigintApplyTwosComplement(inout float [BYTE_COUNT], bool);\n\nvoid bigintRshift(float a[BYTE_COUNT], inout float b[BYTE_COUNT], float f) {\n    bool negative = bigintRemoveTwosComplement(a);\n    biguintRshift(a, b, f);\n    bigintApplyTwosComplement(b, negative);\n}",bigintRshiftByOne:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nbool bigintRemoveTwosComplement(inout float [BYTE_COUNT]);\nvoid biguintRshiftByOne(float [BYTE_COUNT]);\nvoid bigintApplyTwosComplement(inout float [BYTE_COUNT], bool);\n\nvoid bigintRshiftByOne(inout float a[BYTE_COUNT]) {\n    bool negative = bigintRemoveTwosComplement(a);\n    biguintRshiftByOne(a);\n    bigintApplyTwosComplement(a, negative);\n}",bigintSub:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nvoid biguintSub(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);\nvoid bigintAssign(inout float [BYTE_COUNT], float);\n\nvoid bigintSub(float a[BYTE_COUNT], float b[BYTE_COUNT], inout float c[BYTE_COUNT]) {\n    biguintSub(a, b, c);\n}\n\nvoid bigintSub(float a[BYTE_COUNT], float bf, inout float c[BYTE_COUNT]) {\n    float b[BYTE_COUNT];\n    bigintAssign(b, bf);\n    bigintSub(a, b, c);\n}",bigintXor:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nvoid biguintXor(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);\n\nvoid bigintXor(float a[BYTE_COUNT], float b[BYTE_COUNT], inout float c[BYTE_COUNT]) {\n    biguintXor(a, b, c);\n}"};t.functionStrings=f,Object.keys(f).forEach(n=>{const t=f;t[n]=t[n].replace(/\r+/gm,"").replace(/\t/g,"    ").replace(/\n{3,}/g,"\n\n")}),Object.assign(f,e.untouchedFunctionStrings);const T=Object.assign({},f);t.untouchedFunctionStrings=T;const l={bigintAbs:{prepend:["#ifndef BIG_INT_ABS","#define BIG_INT_ABS"].join("\n"),declarations:["void bigintAbs(inout float [BYTE_COUNT]);"],append:"#endif"},bigintAdd:{prepend:["#ifndef BIG_INT_ADD","#define BIG_INT_ADD"].join("\n"),declarations:["void bigintAdd(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);","void bigintAdd(float [BYTE_COUNT], float, inout float [BYTE_COUNT]);"],append:"#endif"},bigintAnd:{prepend:["#ifndef BIG_INT_AND","#define BIG_INT_AND"].join("\n"),declarations:["void bigintAnd(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);"],append:"#endif"},bigintApplyTwosComplement:{prepend:["#ifndef BIG_INT_APPLY_TWOS_COMPLEMENT","#define BIG_INT_APPLY_TWOS_COMPLEMENT"].join("\n"),declarations:["void bigintApplyTwosComplement(inout float [BYTE_COUNT], float);","void bigintApplyTwosComplement(inout float [BYTE_COUNT], bool);"],append:"#endif"},bigintAssign:{prepend:["#ifndef BIG_INT_ASSIGN","#define BIG_INT_ASSIGN"].join("\n"),declarations:["void bigintAssign(inout float [BYTE_COUNT], float [BYTE_COUNT]);","void bigintAssign(inout float [BYTE_COUNT], float);"],append:"#endif"},bigintAssignIfTrue:{prepend:["#ifndef BIG_INT_ASSIGN_IF_TRUE","#define BIG_INT_ASSIGN_IF_TRUE"].join("\n"),declarations:["void bigintAssignIfTrue(inout float [BYTE_COUNT], float [BYTE_COUNT], float);","void bigintAssignIfTrue(inout float [BYTE_COUNT], float [BYTE_COUNT], bool);","void bigintAssignIfTrue(inout float [BYTE_COUNT], float, float);","void bigintAssignIfTrue(inout float [BYTE_COUNT], float, bool);"],append:"#endif"},bigintDiv:{prepend:["#ifndef BIG_INT_DIV","#define BIG_INT_DIV"].join("\n"),declarations:["void bigintDiv(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);","void bigintDiv(float [BYTE_COUNT], float, inout float [BYTE_COUNT]);"],append:"#endif"},bigintEquals:{prepend:["#ifndef BIG_INT_EQUALS","#define BIG_INT_EQUALS"].join("\n"),declarations:["float bigintEquals(float [BYTE_COUNT], float [BYTE_COUNT]);","float bigintEquals(float [BYTE_COUNT], float);"],append:"#endif"},bigintGreaterThan:{prepend:["#ifndef BIG_INT_GREATER_THAN","#define BIG_INT_GREATER_THAN"].join("\n"),declarations:["float bigintGreaterThan(float [BYTE_COUNT], float [BYTE_COUNT]);","float bigintGreaterThan(float [BYTE_COUNT], float);"],append:"#endif"},bigintGreaterThanOrEqual:{prepend:["#ifndef BIG_INT_GREATER_THAN_OR_EQUAL","#define BIG_INT_GREATER_THAN_OR_EQUAL"].join("\n"),declarations:["float bigintGreaterThanOrEqual(float [BYTE_COUNT], float [BYTE_COUNT]);","float bigintGreaterThanOrEqual(float [BYTE_COUNT], float);"],append:"#endif"},bigintLessThan:{prepend:["#ifndef BIG_INT_LESS_THAN","#define BIG_INT_LESS_THAN"].join("\n"),declarations:["float bigintLessThan(float [BYTE_COUNT], float [BYTE_COUNT]);","float bigintLessThan(float [BYTE_COUNT], float);"],append:"#endif"},bigintLessThanOrEqual:{prepend:["#ifndef BIG_INT_LESS_THAN_OR_EQUAL","#define BIG_INT_LESS_THAN_OR_EQUAL"].join("\n"),declarations:["float bigintLessThanOrEqual(float [BYTE_COUNT], float [BYTE_COUNT]);","float bigintLessThanOrEqual(float [BYTE_COUNT], float);"],append:"#endif"},bigintLshift:{prepend:["#ifndef BIG_INT_LSHIFT","#define BIG_INT_LSHIFT"].join("\n"),declarations:["void bigintLshift(float [BYTE_COUNT], inout float [BYTE_COUNT], float);"],append:"#endif"},bigintLshiftByOne:{prepend:["#ifndef BIG_INT_LSHIFT_BY_ONE","#define BIG_INT_LSHIFT_BY_ONE"].join("\n"),declarations:["void bigintLshiftByOne(inout float [BYTE_COUNT]);"],append:"#endif"},bigintMul:{prepend:["#ifndef BIG_INT_MUL","#define BIG_INT_MUL"].join("\n"),declarations:["void bigintMul(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);","void bigintMul(float [BYTE_COUNT], float, inout float [BYTE_COUNT]);"],append:"#endif"},bigintOr:{prepend:["#ifndef BIG_INT_OR","#define BIG_INT_OR"].join("\n"),declarations:["void bigintOr(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);"],append:"#endif"},bigintRemoveTwosComplement:{prepend:["#ifndef BIG_INT_REMOVE_TWOS_COMPLEMENT","#define BIG_INT_REMOVE_TWOS_COMPLEMENT"].join("\n"),declarations:["bool bigintRemoveTwosComplement(inout float [BYTE_COUNT]);"],append:"#endif"},bigintRshift:{prepend:["#ifndef BIG_INT_RSHIFT","#define BIG_INT_RSHIFT"].join("\n"),declarations:["void bigintRshift(float [BYTE_COUNT], inout float [BYTE_COUNT], float);"],append:"#endif"},bigintRshiftByOne:{prepend:["#ifndef BIG_INT_RSHIFT_BY_ONE","#define BIG_INT_RSHIFT_BY_ONE"].join("\n"),declarations:["void bigintRshiftByOne(inout float [BYTE_COUNT]);"],append:"#endif"},bigintSub:{prepend:["#ifndef BIG_INT_SUB","#define BIG_INT_SUB"].join("\n"),declarations:["void bigintSub(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);","void bigintSub(float [BYTE_COUNT], float, inout float [BYTE_COUNT]);"],append:"#endif"},bigintXor:{prepend:["#ifndef BIG_INT_XOR","#define BIG_INT_XOR"].join("\n"),declarations:["void bigintXor(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);"],append:"#endif"}};t.declarations=l,Object.assign(l,e.declarations);const u=[["#ifndef BYTE_COUNT","#define BYTE_COUNT 16","#endif","","#ifdef GL_ES","precision highp float;","precision highp int;","#endif"].join("\n")];Object.assign(f,(0,o.renderDefinitions)(f,l,u))},function(n,t,i){"use strict";function e(n){for(let t=0;t<n.length;t++)n[t]=255-n[t]}function o(n){let t=1;for(let i=0;i<n.length;i++){let e=n[i]+t;e<=255&&(t=0),n[i]=e%256}}Object.defineProperty(t,"__esModule",{value:!0}),t.flipBits=e,t.addOne=o,t.applyTwosComplement=function(n,t){n[n.length-1]>=128&&(n[n.length-1]-=128);t&&(e(n),o(n))},t.removeTwosComplement=function(n){const t=n[n.length-1]>=128;t&&(e(n),o(n));return t},t.bytesToHex=function(n){let t="";for(let i=n.length-1;i>=0;i--){const e=n[i];t+=r[Math.floor(e/16)],t+=r[e%16]}return t},t.hexToBytes=function(n){n.length%2&&(n="0"+n);const t=new Uint8Array(n.length/2);for(let i=0;i<t.length;i++){const e=16*a[n[2*i]],o=a[n[2*i+1]];t[t.length-i-1]=e+o}return t},t.resizeBytes=function(n,t,i){if(n.length===t)return n;if(n.length>t)return i?n.subarray(n.length-t):n.subarray(0,t);return i?new Uint8Array([...Array(t-n.length).fill(0),...n]):new Uint8Array([...n,...Array(t-n.length).fill(0)])};const r=Array.from(Array(16),(n,t)=>t.toString(16));const a={};r.forEach((n,t)=>a[n]=t)},function(n,t,i){"use strict";function e(n,t,i){let e=0;const o=[],r=(n,a)=>{for(let[o,f]of Object.entries(t))for(let t of f.declarations)if(a.includes("\n"+t)){if(e++>1e6)throw new Error(`dependency loop: ${n} ${o}`);r(o,i[o])}n&&!o.includes(n)&&o.push(n)};return r(null,n),o}function o(n,t){for(let i of Object.values(t))for(let t of i.declarations)for(;n.includes("\n"+t);)n=n.replace("\n"+t,"\n");return n}function r(n,t,i,e){let r="";for(let n of t)r+=i[n].prepend+"\n\n",r+=o(e[n],i)+"\n\n",r+=i[n].append+"\n\n";return r+n}function a(n,t){for(let i of t){const t=n.search(i),e=n.substring(0,t+i.length);let o=n.substring(t);for(;o.includes(i);)o=o.replace(i,"");return e+o}return n}Object.defineProperty(t,"__esModule",{value:!0}),t.findDependencies=e,t.removeDependencies=o,t.removeStutters=a,t.renderDefinitions=function(n,t,i){const f={};for(let T of Object.keys(n)){const l=e(n[T],t,n);f[T]=r(n[T],l,t,n),f[T]=o(f[T],t),i&&(f[T]=a(f[T],i)),f[T]=`${t[T].prepend}\n\n${f[T]}`,f[T]=`${f[T]}\n\n${t[T].append}`,f[T]=f[T].replace(/\n{3,}/g,"\n\n")}return f},t.replaceDefinitions=function(n,t,i){const e=[];for(let[o,r]of Object.entries(i))for(let i of r.declarations)n.includes("\n"+i)&&(e.includes(o)?n=n.replace("\n"+i,"\n"):(n=n.replace("\n"+i,"\n\n"+t[o]),e.push(o)));return n}},function(n,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.isBenchmarking=u,t.startBenchmarking=g,t.getBenchmarkText=_,t.getWebGLContext=p,t.default=void 0;var e=function(n){if(n&&n.__esModule)return n;if(null===n||"object"!=typeof n&&"function"!=typeof n)return{default:n};var t=r();if(t&&t.has(n))return t.get(n);var i={},e=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in n)if(Object.prototype.hasOwnProperty.call(n,o)){var a=e?Object.getOwnPropertyDescriptor(n,o):null;a&&(a.get||a.set)?Object.defineProperty(i,o,a):i[o]=n[o]}i.default=n,t&&t.set(n,i);return i}(i(8)),o=i(4);function r(){if("function"!=typeof WeakMap)return null;var n=new WeakMap;return r=function(){return n},n}function a(n,t,i,e,o,r,a){try{var f=n[r](a),T=f.value}catch(n){return void i(n)}f.done?t(T):Promise.resolve(T).then(e,o)}function f(n){return function(){var t=this,i=arguments;return new Promise((function(e,o){var r=n.apply(t,i);function f(n){a(r,e,o,f,T,"next",n)}function T(n){a(r,e,o,f,T,"throw",n)}f(void 0)}))}}let T=!1,l="PENDING!";function u(){return T}const s=n=>(0,o.expandDefinitions)(n.replace(/\r+/gm,"").replace(/\t/g,"    ").replace(/\n{3,}/g,"\n\n")),d="#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nvoid biguintAdd(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);\nvoid bigintAssign(inout float [BYTE_COUNT], float);\n\nvoid bigintAdd(float a[BYTE_COUNT], float b[BYTE_COUNT], inout float c[BYTE_COUNT]) {\n    biguintAdd(a, b, c);\n}\n\nvoid bigintAdd(float a[BYTE_COUNT], float bf, inout float c[BYTE_COUNT]) {\n    float b[BYTE_COUNT];\n    bigintAssign(b, bf);\n    bigintAdd(a, b, c);\n}";function g(){return b.apply(this,arguments)}function b(){return(b=f((function*(){T||(T=!0,l="EXECUTING FOO",setTimeout(()=>{T=!1,l=s(d)},2500))}))).apply(this,arguments)}function _(){return l}function p(){return e.getWebGLContext()}var E={startBenchmarking:g,getBenchmarkText:_,isBenchmarking:u,getWebGLContext:p};t.default=E},function(n,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),Object.defineProperty(t,"setWebGLContext",{enumerable:!0,get:function(){return e.setWebGLContext}}),Object.defineProperty(t,"getWebGLContext",{enumerable:!0,get:function(){return e.getWebGLContext}}),Object.defineProperty(t,"isWebGL2",{enumerable:!0,get:function(){return e.isWebGL2}}),Object.defineProperty(t,"ComputeShader",{enumerable:!0,get:function(){return o.ComputeShader}}),Object.defineProperty(t,"passThruFrag",{enumerable:!0,get:function(){return o.passThruFrag}}),Object.defineProperty(t,"passThruVert",{enumerable:!0,get:function(){return o.passThruVert}}),Object.defineProperty(t,"RenderTarget",{enumerable:!0,get:function(){return r.RenderTarget}}),Object.defineProperty(t,"packBooleans",{enumerable:!0,get:function(){return a.packBooleans}}),Object.defineProperty(t,"unpackBooleans",{enumerable:!0,get:function(){return a.unpackBooleans}}),Object.defineProperty(t,"packInt16",{enumerable:!0,get:function(){return f.packInt16}}),Object.defineProperty(t,"unpackInt16",{enumerable:!0,get:function(){return f.unpackInt16}}),Object.defineProperty(t,"MIN_INT16",{enumerable:!0,get:function(){return f.MIN_INT16}}),Object.defineProperty(t,"MAX_INT16",{enumerable:!0,get:function(){return f.MAX_INT16}}),Object.defineProperty(t,"packUint16",{enumerable:!0,get:function(){return T.packUint16}}),Object.defineProperty(t,"unpackUint16",{enumerable:!0,get:function(){return T.unpackUint16}}),Object.defineProperty(t,"MIN_UINT16",{enumerable:!0,get:function(){return T.MIN_UINT16}}),Object.defineProperty(t,"MAX_UINT16",{enumerable:!0,get:function(){return T.MAX_UINT16}}),Object.defineProperty(t,"functionStrings",{enumerable:!0,get:function(){return l.functionStrings}}),Object.defineProperty(t,"expandDefinitions",{enumerable:!0,get:function(){return l.expandDefinitions}});var e=i(0),o=i(1),r=i(9),a=i(12),f=i(13),T=i(14),l=i(3);n.exports={setWebGLContext:e.setWebGLContext,getWebGLContext:e.getWebGLContext,isWebGL2:e.isWebGL2,ComputeShader:o.ComputeShader,passThruFrag:o.passThruFrag,passThruVert:o.passThruVert,RenderTarget:r.RenderTarget,packBooleans:a.packBooleans,unpackBooleans:a.unpackBooleans,packInt16:f.packInt16,unpackInt16:f.unpackInt16,MIN_INT16:f.MIN_INT16,MAX_INT16:f.MAX_INT16,packUint16:T.packUint16,unpackUint16:T.unpackUint16,MIN_UINT16:T.MIN_UINT16,MAX_UINT16:T.MAX_UINT16,functionStrings:l.functionStrings,expandDefinitions:l.expandDefinitions}},function(n,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.RenderTarget=void 0;var e=i(0),o=i(10),r=i(2);function a(n,t,i){return t in n?Object.defineProperty(n,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):n[t]=i,n}class f{constructor(n,t){a(this,"width",void 0),a(this,"targetAlpha",void 0),a(this,"targetBravo",void 0);const i=(0,e.getMaxRenderBufferSize)();if(!Number.isInteger(n)||n<1||n>i)throw new Error(`ComputeTarget width of '${n}' is out of range (1 to ${i})`);if(Math.log(n)/Math.log(2)%1!=0)throw new Error(`ComputeTarget width of '${n}' is not a power of two`);this.width=n,this.targetAlpha=t||this.createTarget()}compute(n,t){const i=(0,e.getWebGLContext)();return i.useProgram(n.program),this.setBuffers(n,(0,r.getComputeBufferInfo)()),t&&this.setUniforms(n,t),i.bindFramebuffer(i.FRAMEBUFFER,this.targetAlpha.framebuffer),i.viewport(0,0,this.width,this.width),i.drawArrays(i.TRIANGLES,0,6),this}transpose(n){if(n.width!==this.width)throw new Error(`scatterFragCoord width: '${n.width}' != RenderTarget width: '${this.width}'`);const t=(0,e.getWebGLContext)(),i=(0,o.getTransposeShader)();return t.useProgram(i.program),this.setBuffers(i,(0,o.getTransposeBufferInfo)(this.width)),this.setUniforms(i,{u_scatterCoord:n,u_sourceTex:this,u_textureWidth:this.width}),t.bindFramebuffer(t.FRAMEBUFFER,this.targetAlpha.framebuffer),t.viewport(0,0,this.width,this.width),t.drawArrays(t.POINTS,0,this.width*this.width),this}pushSomePixels(n,t,i,o,r){if(r.length!==i*o*4)throw new Error("out.length !== "+i*o*4);const a=(0,e.getWebGLContext)();a.bindTexture(a.TEXTURE_2D,this.targetAlpha.texture),a.texSubImage2D(a.TEXTURE_2D,0,n,t,i,o,a.RGBA,a.UNSIGNED_BYTE,r),a.bindTexture(a.TEXTURE_2D,null)}pushPixelsRecursively(n,t,i,e,o,r,a){const f=Math.min(Math.max(Math.floor(o/i),1),e);if(this.pushSomePixels(n,t,i,f,r.subarray(0,4*i*f)),e-f<=0)return a();requestAnimationFrame(()=>this.pushPixelsRecursively(n,t+f,i,e-f,o,r.subarray(4*i*f),a))}pushSomePixelsAsync(n,t,i,e,o){return new Promise((r,a)=>{if(o.length!==i*e*4)return a(new Error("out.length !== "+i*e*4));this.pushPixelsRecursively(n,t,i,e,262144,o,()=>r())})}pushTextureData(n){const t=this.width,i=n.length/4,e=4*(i-i%t);if(n.length>4*t*t)throw new Error(`array length of: '${n.length}' overflows: '${4*t*t}'`);if(n.length%4>0)throw new Error(`array length of: '${n.length}' is not a multiple of four`);if(t>=i)return this.pushSomePixels(0,0,Math.min(i,t),Math.max(Math.floor(i/t),1),n);this.pushSomePixels(0,0,Math.min(i,t),Math.max(Math.floor(i/t),1),n.subarray(0,e)),4*t*t>n.length&&this.pushSomePixels(0,Math.floor(i/t),i%t,1,n.subarray(e))}pushTextureDataAsync(n){return new Promise((t,i)=>{const e=this.width,o=n.length/4,r=4*(o-o%e);return n.length>4*e*e?i(new Error(`array length of: '${n.length}' overflows: '${4*e*e}'`)):n.length%4>0?i(new Error(`array length of: '${n.length}' is not a multiple of four`)):void(e>=o?this.pushSomePixelsAsync(0,0,Math.min(o,e),Math.max(Math.floor(o/e),1),n).then(()=>t()).catch(n=>i(n)):4*e*e>n.length?this.pushSomePixelsAsync(0,0,Math.min(o,e),Math.max(Math.floor(o/e),1),n.subarray(0,r)).then(()=>this.pushSomePixelsAsync(0,Math.floor(o/this.width),o%this.width,1,n.subarray(r)).then(()=>t()).catch(n=>i(n))).catch(n=>i(n)):this.pushSomePixelsAsync(0,0,Math.min(o,e),Math.max(Math.floor(o/e),1),n.subarray(0,r)).then(()=>t()).catch(n=>i(n)))})}readPixels(n){return this.readSomePixels(0,0,this.width,this.width,n)}readPixelsAsync(n){return this.readSomePixelsAsync(0,0,this.width,this.width,n)}readSomePixels(n,t,i,o,r){r||(r=new Uint8Array(i*o*4));const a=(0,e.getWebGLContext)();return a.bindFramebuffer(a.FRAMEBUFFER,this.targetAlpha.framebuffer),a.readPixels(n,t,i,o,a.RGBA,a.UNSIGNED_BYTE,r),a.bindFramebuffer(a.FRAMEBUFFER,null),r}readPixelsRecursively(n,t,i,e,o,r,a){const f=Math.min(Math.max(Math.floor(o/i),1),e);if(this.readSomePixels(n,t,i,f,r.subarray(0,4*i*f)),e-f<=0)return a();requestAnimationFrame(()=>this.readPixelsRecursively(n,t+f,i,e-f,o,r.subarray(4*i*f),a))}readSomePixelsAsync(n,t,i,e,o){return new Promise((r,a)=>{if(o||(o=new Uint8Array(i*e*4)),o.length!==i*e*4)return a(new Error("out.length !== "+i*e*4));this.readPixelsRecursively(n,t,i,e,262144,o,()=>r(o))})}delete(){const n=(0,e.getWebGLContext)();n.deleteTexture(this.targetAlpha.texture),n.deleteFramebuffer(this.targetAlpha.framebuffer),this.targetBravo&&(n.deleteTexture(this.targetBravo.texture),n.deleteFramebuffer(this.targetBravo.framebuffer))}getBackbuffer(){return this.targetBravo?new f(this.width,this.targetBravo):null}deleteBackbuffer(){if(this.targetBravo){const n=(0,e.getWebGLContext)();n.deleteTexture(this.targetBravo.texture),n.deleteFramebuffer(this.targetBravo.framebuffer)}}setBuffers(n,t){const i=(0,e.getWebGLContext)();for(var o in t){const e=t[o].buffer,r=t[o].numComponents,a=n.attributeInfo[o].location;i.bindBuffer(i.ARRAY_BUFFER,e),i.enableVertexAttribArray(a),i.vertexAttribPointer(a,r,i.FLOAT,!1,0,0),i.bindBuffer(i.ARRAY_BUFFER,null)}}setUniforms(n,t){let i=0,o=!1;const r=(0,e.getWebGLContext)();for(let e in n.uniformInfo){if(void 0===t[e])continue;if(n.uniformInfo[e].type!==r.SAMPLER_2D)continue;const a=t[e];if(a.targetAlpha.texture===this.targetAlpha.texture&&(o||i++,o=!0),this.targetBravo&&this.targetBravo.texture===a.targetAlpha.texture)throw new Error(`provided uniform: '${e}' cannot be the RenderTarget's backbuffer`)}for(let e in n.uniformInfo){if(void 0===t[e])continue;const o=t[e],a=n.uniformInfo[e].type,f=n.uniformInfo[e].location;switch(a){case r.SAMPLER_2D:if(Array.isArray(o)||"number"==typeof o)throw new Error(`provided uniform: '${e}' is not a WebGLTexture`);r.uniform1i(f,i),r.activeTexture(r.TEXTURE0+i++),r.bindTexture(r.TEXTURE_2D,o.targetAlpha.texture);break;case r.FLOAT:"number"==typeof o?r.uniform1f(f,o):Array.isArray(o)&&r.uniform1fv(f,o);break;case r.FLOAT_VEC2:case r.FLOAT_VEC3:case r.FLOAT_VEC4:throw new Error("uniform vectors are currently unsupported");default:throw new Error(`unsupported uniform type: '${a}'`)}}o&&(this.targetBravo||(this.targetBravo=this.createTarget()),[this.targetAlpha,this.targetBravo]=[this.targetBravo,this.targetAlpha])}createTarget(){const n=(0,e.getWebGLContext)(),t=n.createFramebuffer();if(!t)throw new Error("unable to create framebuffer");const i=n.createTexture();if(!i)throw new Error("unable to create texture");return n.bindFramebuffer(n.FRAMEBUFFER,t),n.activeTexture(n.TEXTURE0),n.bindTexture(n.TEXTURE_2D,i),n.texImage2D(n.TEXTURE_2D,0,n.RGBA,this.width,this.width,0,n.RGBA,n.UNSIGNED_BYTE,null),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MAG_FILTER,n.NEAREST),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MIN_FILTER,n.NEAREST),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,i,0),n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),{framebuffer:t,texture:i}}}t.RenderTarget=f},function(n,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getTransposeBufferInfo=function(n){if(n<2||n>4096)throw new Error(`width of '${n}' is out of range (2 to 4096)`);const t=Math.log(n)/Math.log(2);if(t%1!=0)throw new Error(`width of '${n}' is not a power of two`);if(!l[t]){const n=Math.pow(2,t),a=new Float32Array(2*n*n);for(var i=0,e=0;e<n;e++)for(var r=0;r<n;r++)a[i++]=2*(r+.5)/n-1,a[i++]=2*(e+.5)/n-1;const f=(0,o.createBufferInfoFromArrays)({a_position:{data:a,numComponents:2}});l[t]=f}return l[t]},t.getTransposeShader=function(){if(u)return u;const n=(0,e.getWebGLContext)(),t=n.getParameter(n.MAX_VERTEX_TEXTURE_IMAGE_UNITS);if(t<2)throw new Error(`MAX_VERTEX_TEXTURE_IMAGE_UNITS: '${t}' is less than 2`);const i={"float vec2ToUint16(vec2 v);":a.functionStrings.vec2ToUint16};return u=new r.ComputeShader(T,i,f)},t.passThruTransposeFrag=t.passThruTransposeVert=void 0;var e=i(0),o=i(2),r=i(1),a=i(3);const f="\n#ifdef GL_ES\nprecision mediump float;\nprecision mediump int;\nprecision mediump sampler2D;\n#endif\n\nuniform sampler2D u_scatterCoord;\nuniform sampler2D u_sourceTex;\nuniform float u_textureWidth;\nattribute vec2 a_position;\nvarying vec4 v_sourceTexel;\n\nfloat vec2ToUint16(vec2 v);\n\nvoid main() {\n  gl_PointSize = 1.0;\n  vec4 destinationTexel = texture2D(u_scatterCoord, vec2(a_position.x + 1.0, a_position.y + 1.0) / 2.0);\n  vec2 destinationCoord = vec2(vec2ToUint16(destinationTexel.rg) + 0.5, vec2ToUint16(destinationTexel.ba) + 0.5);\n  gl_Position = vec4(2.0 * (destinationCoord.xy / u_textureWidth) - vec2(1.0, 1.0), 0.0, 1.0);\n  v_sourceTexel = texture2D(u_sourceTex, vec2(a_position.x + 1.0, a_position.y + 1.0) / 2.0);\n}";t.passThruTransposeVert=f;const T="\n#ifdef GL_ES\nprecision mediump float;\nprecision mediump int;\nprecision mediump sampler2D;\n#endif\n\nvarying vec4 v_sourceTexel;\n\nvoid main() {\n  gl_FragColor = v_sourceTexel;\n}";t.passThruTransposeFrag=T;const l=new Array(13);var u},function(n,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.decodeUnsignedBytes=function(n,t){t&&n.reverse();return BigInt("0x"+(0,e.bytesToHex)(n))},t.encodeUnsignedBytes=function(n,t){n<BigInt(0)&&(n=BigInt(0));const i=(0,e.hexToBytes)(n.toString(16));t&&i.reverse();return i},t.expandDefinitions=function(n){return n=(0,o.replaceDefinitions)(n,r,f),(0,o.removeStutters)(n,T).replace(/\n{3,}/g,"\n\n")},t.declarations=t.untouchedFunctionStrings=t.functionStrings=void 0;var e=i(5),o=i(6);const r={biguintAdd:"#ifndef BYTE_COUNT\r\n#define BYTE_COUNT 16\r\n#endif\r\n\r\n#ifdef GL_ES\r\nprecision highp float;\r\nprecision highp int;\r\n#endif\r\n\r\nvoid biguintAssign(inout float [BYTE_COUNT], float);\r\n\r\nvoid biguintAdd(float a[BYTE_COUNT], float b[BYTE_COUNT], inout float c[BYTE_COUNT]) {\r\n    float carry, tmp;\r\n    for (int i = 0; i < BYTE_COUNT; i++) {\r\n        tmp = a[i] + b[i] + carry;\r\n        carry = floor(tmp / 256.0);\r\n        c[i] = mod(tmp, 256.0);\r\n    }\r\n}\r\n\r\nvoid biguintAdd(float a[BYTE_COUNT], float bf, inout float c[BYTE_COUNT]) {\r\n    float b[BYTE_COUNT];\r\n    biguintAssign(b, bf);\r\n    biguintAdd(a, b, c);\r\n}",biguintAnd:"#ifndef BYTE_COUNT\r\n#define BYTE_COUNT 16\r\n#endif\r\n\r\n#ifdef GL_ES\r\nprecision highp float;\r\nprecision highp int;\r\n#endif\r\n\r\n#ifndef FLOAT_GTE\r\n#define FLOAT_GTE\r\nfloat gte(float f1, float f2) {\r\n  return 1.0 - max(sign(f2 - f1), 0.0); \r\n}\r\n#endif\r\n\r\nvoid biguintAnd(float a[BYTE_COUNT], float b[BYTE_COUNT], inout float c[BYTE_COUNT]) {\r\n    for (int i = 0; i < BYTE_COUNT; i++) {\r\n        float o = gte(a[i], 128.0) * gte(b[i], 128.0) * 128.0;\r\n        a[i] -= gte(a[i], 128.0) * 128.0;\r\n        b[i] -= gte(b[i], 128.0) * 128.0;\r\n        o += gte(a[i], 64.0) * gte(b[i], 64.0) * 64.0;\r\n        a[i] -= gte(a[i], 64.0) * 64.0;\r\n        b[i] -= gte(b[i], 64.0) * 64.0;\r\n        o += gte(a[i], 32.0) * gte(b[i], 32.0) * 32.0;\r\n        a[i] -= gte(a[i], 32.0) * 32.0;\r\n        b[i] -= gte(b[i], 32.0) * 32.0;\r\n        o += gte(a[i], 16.0) * gte(b[i], 16.0) * 16.0;\r\n        a[i] -= gte(a[i], 16.0) * 16.0;\r\n        b[i] -= gte(b[i], 16.0) * 16.0;\r\n        o += gte(a[i], 8.0) * gte(b[i], 8.0) * 8.0;\r\n        a[i] -= gte(a[i], 8.0) * 8.0;\r\n        b[i] -= gte(b[i], 8.0) * 8.0;\r\n        o += gte(a[i], 4.0) * gte(b[i], 4.0) * 4.0;\r\n        a[i] -= gte(a[i], 4.0) * 4.0;\r\n        b[i] -= gte(b[i], 4.0) * 4.0;\r\n        o += gte(a[i], 2.0) * gte(b[i], 2.0) * 2.0;\r\n        a[i] -= gte(a[i], 2.0) * 2.0;\r\n        b[i] -= gte(b[i], 2.0) * 2.0;\r\n        c[i] = o + gte(a[i], 1.0) * gte(b[i], 1.0);\r\n    }\r\n}",biguintAssign:"#ifndef BYTE_COUNT\r\n#define BYTE_COUNT 16\r\n#endif\r\n\r\n#ifdef GL_ES\r\nprecision highp float;\r\nprecision highp int;\r\n#endif\r\n\r\nvoid biguintAssign(inout float dst[BYTE_COUNT], float src[BYTE_COUNT]) {\r\n    for (int i = 0; i < BYTE_COUNT; i++) dst[i] = src[i];\r\n}\r\n\r\nvoid biguintAssign(inout float dst[BYTE_COUNT], float f) {\r\n    f = clamp(floor(f), 0.0, 65535.0);\r\n    dst[0] = mod(f, 256.0);\r\n    dst[1] = floor(f / 256.0);\r\n    for (int i = 2; i < BYTE_COUNT; i++) dst[i] = 0.0;\r\n}",biguintAssignIfTrue:"#ifndef BYTE_COUNT\r\n#define BYTE_COUNT 16\r\n#endif\r\n\r\n#ifdef GL_ES\r\nprecision highp float;\r\nprecision highp int;\r\n#endif\r\n\r\nvoid biguintAssign(inout float [BYTE_COUNT], float);\r\n\r\nvoid biguintAssignIfTrue(inout float dst[BYTE_COUNT], float src[BYTE_COUNT], float f) {\r\n    for (int i = 0; i < BYTE_COUNT; i++) \r\n        dst[i] = src[i] * float(f != 0.0)\r\n               + dst[i] * float(f == 0.0);\r\n}\r\n\r\nvoid biguintAssignIfTrue(inout float dst[BYTE_COUNT], float src[BYTE_COUNT], bool b) {\r\n    biguintAssignIfTrue(dst, src, float(b));\r\n}\r\n\r\nvoid biguintAssignIfTrue(inout float dst[BYTE_COUNT], float sf, float f) {\r\n    float src[BYTE_COUNT];\r\n    biguintAssign(dst, sf);\r\n    biguintAssignIfTrue(dst, src, f);\r\n}\r\n\r\nvoid biguintAssignIfTrue(inout float dst[BYTE_COUNT], float sf, bool b) {\r\n    float src[BYTE_COUNT];\r\n    biguintAssign(dst, sf);\r\n    biguintAssignIfTrue(dst, src, float(b));\r\n}",biguintDiv:"#ifndef BYTE_COUNT\r\n#define BYTE_COUNT 16\r\n#endif\r\n\r\n#ifdef GL_ES\r\nprecision highp float;\r\nprecision highp int;\r\n#endif\r\n\r\nvoid biguintRshift(float [BYTE_COUNT], inout float [BYTE_COUNT], float);\r\nfloat biguintGreaterThan(float [BYTE_COUNT], float [BYTE_COUNT]);\r\nvoid biguintLshiftByOne(inout float [BYTE_COUNT]);\r\nvoid biguintRshiftByOne(inout float [BYTE_COUNT]);\r\nvoid biguintAssign(inout float [BYTE_COUNT], float [BYTE_COUNT]);\r\nvoid biguintAssign(inout float [BYTE_COUNT], float);\r\nvoid biguintAssignIfTrue(inout float [BYTE_COUNT], float [BYTE_COUNT], float);\r\nfloat biguintGreaterThanOrEqual(float [BYTE_COUNT], float [BYTE_COUNT]);\r\nvoid biguintSub(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);\r\nvoid biguintOr(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);\r\nfloat biguintLshiftByte(float, float);\r\nfloat biguintRshiftByte(float, float);\r\nfloat biguintOrByte(float, float);\r\n\r\nvoid biguintDiv(float a[BYTE_COUNT], float b[BYTE_COUNT], inout float c[BYTE_COUNT]) {\r\n    float nonEmptyBytes, powerOfTwoBit;\r\n    for (int i = 0; i < BYTE_COUNT; i++) {\r\n        nonEmptyBytes += float(b[i] != 0.0);\r\n        powerOfTwoBit = float(i*8+0) * float(b[i] == 1.0)\r\n                      + float(i*8+1) * float(b[i] == 2.0)\r\n                      + float(i*8+2) * float(b[i] == 4.0)\r\n                      + float(i*8+3) * float(b[i] == 8.0)\r\n                      + float(i*8+4) * float(b[i] == 16.0)\r\n                      + float(i*8+5) * float(b[i] == 32.0)\r\n                      + float(i*8+6) * float(b[i] == 64.0)\r\n                      + float(i*8+7) * float(b[i] == 128.0);\r\n    }\r\n    if (nonEmptyBytes == 1.0 && powerOfTwoBit != 0.0) {\r\n        biguintRshift(a, c, powerOfTwoBit);\r\n    } else {\r\n        for (int i = 0; i < BYTE_COUNT; i++) c[i] = 0.0;\r\n        float current[BYTE_COUNT], denom[BYTE_COUNT], t1[BYTE_COUNT];\r\n        current[0] = 1.0;\r\n        biguintAssign(denom, b);\r\n        biguintAssign(t1, a);\r\n        bool overflow;\r\n        for (int i = 0; i < 8*BYTE_COUNT; i++) {\r\n            if (biguintGreaterThan(denom, a) == 1.0) {\r\n                break;\r\n            } \r\n            if (denom[BYTE_COUNT-1] >= 128.0) {\r\n                overflow = true;\r\n                break;\r\n            }\r\n            biguintLshiftByOne(current);\r\n            biguintLshiftByOne(denom);\r\n        }\r\n        if (!overflow) {\r\n            biguintRshiftByOne(denom);\r\n            biguintRshiftByOne(current);\r\n        }\r\n        for (int i = 0; i < 8*BYTE_COUNT; i++) {\r\n            float isZero = 1.0;\r\n            for (int j = 0; j < BYTE_COUNT; j++) isZero -= isZero * float(current[j] != 0.0);\r\n            if (isZero == 1.0) break;\r\n            if (biguintGreaterThanOrEqual(t1, denom) == 1.0) {\r\n                biguintSub(t1, denom, t1);\r\n                biguintOr(c, current, c);\r\n            }\r\n            biguintRshiftByOne(current);\r\n            biguintRshiftByOne(denom);\r\n        }\r\n    }\r\n}\r\n\r\nvoid biguintDiv(float a[BYTE_COUNT], float bf, inout float c[BYTE_COUNT]) {\r\n    float b[BYTE_COUNT];\r\n    biguintAssign(b, bf);\r\n    biguintDiv(a, b, c);\r\n}",biguintEquals:"#ifndef BYTE_COUNT\r\n#define BYTE_COUNT 16\r\n#endif\r\n\r\n#ifdef GL_ES\r\nprecision highp float;\r\nprecision highp int;\r\n#endif\r\n\r\nvoid biguintAssign(inout float [BYTE_COUNT], float);\r\n\r\nfloat biguintEquals(float a[BYTE_COUNT], float b[BYTE_COUNT]) {\r\n    float cmp;\r\n    for (int i = BYTE_COUNT - 1; i >= 0; i--)\r\n        cmp += float(cmp == 0.0) * float(a[i] > b[i])\r\n             - float(cmp == 0.0) * float(a[i] < b[i]);\r\n    return float(cmp == 0.0);\r\n}\r\n\r\nfloat biguintEquals(float a[BYTE_COUNT], float bf) {\r\n    float b[BYTE_COUNT];\r\n    biguintAssign(b, bf);\r\n    return biguintEquals(a, b);\r\n}",biguintGreaterThan:"#ifndef BYTE_COUNT\r\n#define BYTE_COUNT 16\r\n#endif\r\n\r\n#ifdef GL_ES\r\nprecision highp float;\r\nprecision highp int;\r\n#endif\r\n\r\nvoid biguintAssign(inout float [BYTE_COUNT], float);\r\n\r\nfloat biguintGreaterThan(float a[BYTE_COUNT], float b[BYTE_COUNT]) {\r\n    float cmp;\r\n    for (int i = BYTE_COUNT - 1; i >= 0; i--)\r\n        cmp += float(cmp == 0.0) * float(a[i] > b[i])\r\n             - float(cmp == 0.0) * float(a[i] < b[i]);\r\n    return float(cmp == 1.0);\r\n}\r\n\r\nfloat biguintGreaterThan(float a[BYTE_COUNT], float bf) {\r\n    float b[BYTE_COUNT];\r\n    biguintAssign(b, bf);\r\n    return biguintGreaterThan(a, b);\r\n}",biguintGreaterThanOrEqual:"#ifndef BYTE_COUNT\r\n#define BYTE_COUNT 16\r\n#endif\r\n\r\n#ifdef GL_ES\r\nprecision highp float;\r\nprecision highp int;\r\n#endif\r\n\r\nvoid biguintAssign(inout float [BYTE_COUNT], float);\r\n\r\nfloat biguintGreaterThanOrEqual(float a[BYTE_COUNT], float b[BYTE_COUNT]) {\r\n    float cmp;\r\n    for (int i = BYTE_COUNT - 1; i >= 0; i--)\r\n        cmp += float(cmp == 0.0) * float(a[i] > b[i])\r\n             - float(cmp == 0.0) * float(a[i] < b[i]);\r\n    return float(cmp != -1.0);\r\n}\r\n\r\nfloat biguintGreaterThanOrEqual(float a[BYTE_COUNT], float bf) {\r\n    float b[BYTE_COUNT];\r\n    biguintAssign(b, bf);\r\n    return biguintGreaterThanOrEqual(a, b);\r\n}",biguintLessThan:"#ifndef BYTE_COUNT\r\n#define BYTE_COUNT 16\r\n#endif\r\n\r\n#ifdef GL_ES\r\nprecision highp float;\r\nprecision highp int;\r\n#endif\r\n\r\nvoid biguintAssign(inout float [BYTE_COUNT], float);\r\n\r\nfloat biguintLessThan(float a[BYTE_COUNT], float b[BYTE_COUNT]) {\r\n    float cmp;\r\n    for (int i = BYTE_COUNT - 1; i >= 0; i--)\r\n        cmp += float(cmp == 0.0) * float(a[i] > b[i])\r\n             - float(cmp == 0.0) * float(a[i] < b[i]);\r\n    return float(cmp == -1.0);\r\n}\r\n\r\nfloat biguintLessThan(float a[BYTE_COUNT], float bf) {\r\n    float b[BYTE_COUNT];\r\n    biguintAssign(b, bf);\r\n    return biguintLessThan(a, b);\r\n}",biguintLessThanOrEqual:"#ifndef BYTE_COUNT\r\n#define BYTE_COUNT 16\r\n#endif\r\n\r\n#ifdef GL_ES\r\nprecision highp float;\r\nprecision highp int;\r\n#endif\r\n\r\nvoid biguintAssign(inout float [BYTE_COUNT], float);\r\n\r\nfloat biguintLessThanOrEqual(float a[BYTE_COUNT], float b[BYTE_COUNT]) {\r\n    float cmp;\r\n    for (int i = BYTE_COUNT - 1; i >= 0; i--)\r\n        cmp += float(cmp == 0.0) * float(a[i] > b[i])\r\n             - float(cmp == 0.0) * float(a[i] < b[i]);\r\n    return float(cmp != 1.0);\r\n}\r\n\r\nfloat biguintLessThanOrEqual(float a[BYTE_COUNT], float bf) {\r\n    float b[BYTE_COUNT];\r\n    biguintAssign(b, bf);\r\n    return biguintLessThanOrEqual(a, b);\r\n}",biguintLshift:"#ifndef BYTE_COUNT\r\n#define BYTE_COUNT 16\r\n#endif\r\n\r\n#ifdef GL_ES\r\nprecision highp float;\r\nprecision highp int;\r\n#endif\r\n\r\nvoid biguintLshiftWord(inout float [BYTE_COUNT], float);\r\nfloat biguintLshiftByte(float, float);\r\nvoid biguintRshiftWord(inout float [BYTE_COUNT], float);\r\nfloat biguintRshiftByte(float, float);\r\nfloat biguintOrByte(float, float);\r\nvoid biguintAssign(inout float [BYTE_COUNT], float [BYTE_COUNT]);\r\nvoid biguintAssignIfTrue(inout float [BYTE_COUNT], float [BYTE_COUNT], float);\r\n\r\nvoid biguintLshift(float a[BYTE_COUNT], inout float b[BYTE_COUNT], float count) {\r\n    count = clamp(floor(count), 0.0, float(BYTE_COUNT*8));\r\n    biguintAssign(b, a);\r\n    biguintLshiftWord(b, floor(count / 8.0));\r\n    float bits = mod(count, 8.0);\r\n    float t1[BYTE_COUNT];\r\n    biguintAssign(t1, b);\r\n    for (int i = BYTE_COUNT - 1; i > 0; i--) \r\n        t1[i] = biguintOrByte(biguintLshiftByte(t1[i], bits), \r\n                              biguintRshiftByte(t1[i-1], 8.0-bits));\r\n    t1[0] = biguintLshiftByte(t1[0], bits);\r\n    biguintAssignIfTrue(b, t1, float(bits != 0.0));\r\n}",biguintLshiftByOne:"#ifndef BYTE_COUNT\r\n#define BYTE_COUNT 16\r\n#endif\r\n\r\n#ifdef GL_ES\r\nprecision highp float;\r\nprecision highp int;\r\n#endif\r\n\r\nfloat biguintLshiftByte(float, float);\r\nfloat biguintRshiftByte(float, float);\r\nfloat biguintOrByte(float, float);\r\n\r\nvoid biguintLshiftByOne(inout float a[BYTE_COUNT]) {\r\n    for (int i = BYTE_COUNT - 1; i > 0; i--) \r\n        a[i] = biguintOrByte(biguintLshiftByte(a[i], 1.0), \r\n                             biguintRshiftByte(a[i-1], 8.0-1.0));\r\n    a[0] = biguintLshiftByte(a[0], 1.0);\r\n}",biguintLshiftByte:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nfloat biguintLshiftByte(float i, float m) {\n    return mod(floor(i * float(m == 0.0)\n                   + i * float(m == 1.0) * 2.0\n                   + i * float(m == 2.0) * 4.0\n                   + i * float(m == 3.0) * 8.0\n                   + i * float(m == 4.0) * 16.0\n                   + i * float(m == 5.0) * 32.0\n                   + i * float(m == 6.0) * 64.0\n                   + i * float(m == 7.0) * 128.0), 256.0);\n}",biguintLshiftWord:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nvoid biguintLshiftWord(inout float a[BYTE_COUNT], float count) {\n    for (int i = BYTE_COUNT - 1; i >= 0; i--)\n        a[i] = a[int(max(float(i)-count, 0.0))] \n             * float(float(i)-count >= 0.0);\n}",biguintMod:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nvoid biguintDiv(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);\nvoid biguintMul(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);\nvoid biguintSub(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);\nvoid biguintLshift(float [BYTE_COUNT], inout float [BYTE_COUNT], float);\nvoid biguintAssign(inout float [BYTE_COUNT], float);\n\nvoid biguintMod(float ia[BYTE_COUNT], float ib[BYTE_COUNT], inout float oc[BYTE_COUNT]) {\n\tfloat tc[BYTE_COUNT];\n\tbiguintDiv(ia, ib, oc);\n    biguintMul(oc, ib, tc);\n    biguintSub(ia, tc, oc);\n}\n\nvoid biguintMod(float ia[BYTE_COUNT], float ibf, inout float oc[BYTE_COUNT]) {\n    float ib[BYTE_COUNT], tc[BYTE_COUNT];\n    biguintAssign(ib, ibf);\n    biguintDiv(ia, ib, oc);\n    biguintMul(oc, ib, tc);\n    biguintSub(ia, tc, oc);\n}",biguintMul:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nvoid biguintLshift(float [BYTE_COUNT], inout float [BYTE_COUNT], float);\nvoid biguintAssign(inout float [BYTE_COUNT], float);\n\nvoid biguintMul(float a[BYTE_COUNT], float b[BYTE_COUNT], inout float c[BYTE_COUNT]) {\n    float nonEmptyBytes, powerOfTwoBit;\n    for (int i = 0; i < BYTE_COUNT; i++) {\n        nonEmptyBytes += float(b[i] != 0.0);\n        powerOfTwoBit = float(i*8+0) * float(b[i] == 1.0)\n                      + float(i*8+1) * float(b[i] == 2.0)\n                      + float(i*8+2) * float(b[i] == 4.0)\n                      + float(i*8+3) * float(b[i] == 8.0)\n                      + float(i*8+4) * float(b[i] == 16.0)\n                      + float(i*8+5) * float(b[i] == 32.0)\n                      + float(i*8+6) * float(b[i] == 64.0)\n                      + float(i*8+7) * float(b[i] == 128.0);\n    }\n    if (nonEmptyBytes == 1.0 && powerOfTwoBit != 0.0) {\n        biguintLshift(a, c, powerOfTwoBit);\n    } else {\n        float product, carry;\n        float t1[BYTE_COUNT*2];\n        for (int i = 0; i < BYTE_COUNT; i++) {\n            for (int j = 0; j < BYTE_COUNT; j++) {\n                product = a[i] * b[j] + t1[i+j];\n                carry = floor(product / 256.0);\n                t1[i+j] = product - carry * 256.0;\n                t1[i+j+1] += carry;\n            }\n        }\n        float isOver = 0.0;\n        for (int i = BYTE_COUNT; i < 2*BYTE_COUNT; i++) isOver += min(t1[i], 1.0);\n        for (int i = 0; i < BYTE_COUNT; i++) c[i] = t1[i] * (1.0 - isOver) + 255.0 * isOver;\n    }\n}\n\nvoid biguintMul(float a[BYTE_COUNT], float bf, inout float c[BYTE_COUNT]) {\n    float b[BYTE_COUNT];\n    biguintAssign(b, bf);\n    biguintMul(a, b, c);\n}",biguintOr:"#ifndef BYTE_COUNT\r\n#define BYTE_COUNT 16\r\n#endif\r\n\r\n#ifdef GL_ES\r\nprecision highp float;\r\nprecision highp int;\r\n#endif\r\n\r\n#ifndef FLOAT_GTE\r\n#define FLOAT_GTE\r\nfloat gte(float f1, float f2) {\r\n  return 1.0 - max(sign(f2 - f1), 0.0);\r\n}\r\n#endif\r\n\r\nvoid biguintOr(float a[BYTE_COUNT], float b[BYTE_COUNT], inout float c[BYTE_COUNT]) {\r\n    for (int i = 0; i < BYTE_COUNT; i++) {\r\n        float o = max(gte(a[i], 128.0), gte(b[i], 128.0)) * 128.0;\r\n        a[i] -= gte(a[i], 128.0) * 128.0;\r\n        b[i] -= gte(b[i], 128.0) * 128.0;\r\n        o += max(gte(a[i], 64.0), gte(b[i], 64.0)) * 64.0;\r\n        a[i] -= gte(a[i], 64.0) * 64.0;\r\n        b[i] -= gte(b[i], 64.0) * 64.0;\r\n        o += max(gte(a[i], 32.0), gte(b[i], 32.0)) * 32.0;\r\n        a[i] -= gte(a[i], 32.0) * 32.0;\r\n        b[i] -= gte(b[i], 32.0) * 32.0;\r\n        o += max(gte(a[i], 16.0), gte(b[i], 16.0)) * 16.0;\r\n        a[i] -= gte(a[i], 16.0) * 16.0;\r\n        b[i] -= gte(b[i], 16.0) * 16.0;\r\n        o += max(gte(a[i], 8.0), gte(b[i], 8.0)) * 8.0;\r\n        a[i] -= gte(a[i], 8.0) * 8.0;\r\n        b[i] -= gte(b[i], 8.0) * 8.0;\r\n        o += max(gte(a[i], 4.0), gte(b[i], 4.0)) * 4.0;\r\n        a[i] -= gte(a[i], 4.0) * 4.0;\r\n        b[i] -= gte(b[i], 4.0) * 4.0;\r\n        o += max(gte(a[i], 2.0), gte(b[i], 2.0)) * 2.0;\r\n        a[i] -= gte(a[i], 2.0) * 2.0;\r\n        b[i] -= gte(b[i], 2.0) * 2.0;\r\n        c[i] = o + max(gte(a[i], 1.0), gte(b[i], 1.0));\r\n    }\r\n}",biguintOrByte:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\n#ifndef FLOAT_GTE\n#define FLOAT_GTE\nfloat gte(float f1, float f2) {\n  return 1.0 - max(sign(f2 - f1), 0.0);\n}\n#endif\n\nfloat biguintOrByte(float a, float b) {\n    float o = max(gte(a, 128.0), gte(b, 128.0)) * 128.0;\n    a -= gte(a, 128.0) * 128.0;\n    b -= gte(b, 128.0) * 128.0;\n    o += max(gte(a, 64.0), gte(b, 64.0)) * 64.0;\n    a -= gte(a, 64.0) * 64.0;\n    b -= gte(b, 64.0) * 64.0;\n    o += max(gte(a, 32.0), gte(b, 32.0)) * 32.0;\n    a -= gte(a, 32.0) * 32.0;\n    b -= gte(b, 32.0) * 32.0;\n    o += max(gte(a, 16.0), gte(b, 16.0)) * 16.0;\n    a -= gte(a, 16.0) * 16.0;\n    b -= gte(b, 16.0) * 16.0;\n    o += max(gte(a, 8.0), gte(b, 8.0)) * 8.0;\n    a -= gte(a, 8.0) * 8.0;\n    b -= gte(b, 8.0) * 8.0;\n    o += max(gte(a, 4.0), gte(b, 4.0)) * 4.0;\n    a -= gte(a, 4.0) * 4.0;\n    b -= gte(b, 4.0) * 4.0;\n    o += max(gte(a, 2.0), gte(b, 2.0)) * 2.0;\n    a -= gte(a, 2.0) * 2.0;\n    b -= gte(b, 2.0) * 2.0;\n    return o + max(gte(a, 1.0), gte(b, 1.0));\n}",biguintPow:"#ifndef BYTE_COUNT\r\n#define BYTE_COUNT 16\r\n#endif\r\n\r\n#ifdef GL_ES\r\nprecision highp float;\r\nprecision highp int;\r\n#endif\r\n\r\nvoid biguintSub(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);\r\nvoid biguintMul(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);\r\nvoid biguintAssign(inout float [BYTE_COUNT], float [BYTE_COUNT]);\r\nvoid biguintAssignIfTrue(inout float [BYTE_COUNT], float [BYTE_COUNT], float);\r\n\r\nvoid biguintPow(float a[BYTE_COUNT], float bf, inout float c[BYTE_COUNT]) {\r\n    bf = max(floor(bf), 0.0);\r\n    c[0] = 1.0;\r\n    for (int i = 1; i < BYTE_COUNT; i++) c[i] = 0.0;\r\n    biguintAssignIfTrue(c, a, float(bf != 0.0));\r\n    for (int i = 0; i < 65536; i++) {\r\n        if (bf <= 1.0) break;\r\n        biguintMul(c, a, c);\r\n        bf -= 1.0;\r\n    }\r\n}",biguintRshift:"#ifndef BYTE_COUNT\r\n#define BYTE_COUNT 16\r\n#endif\r\n\r\n#ifdef GL_ES\r\nprecision highp float;\r\nprecision highp int;\r\n#endif\r\n\r\nvoid biguintLshiftWord(inout float [BYTE_COUNT], float);\r\nfloat biguintLshiftByte(float, float);\r\nvoid biguintRshiftWord(inout float [BYTE_COUNT], float);\r\nfloat biguintRshiftByte(float, float);\r\nfloat biguintOrByte(float, float);\r\nvoid biguintAssign(inout float [BYTE_COUNT], float [BYTE_COUNT]);\r\nvoid biguintAssignIfTrue(inout float [BYTE_COUNT], float [BYTE_COUNT], float);\r\n\r\nvoid biguintRshift(float a[BYTE_COUNT], inout float b[BYTE_COUNT], float count) {\r\n    count = clamp(floor(count), 0.0, float(BYTE_COUNT*8));\r\n    biguintAssign(b, a);\r\n    biguintRshiftWord(b, floor(count / 8.0));\r\n    float bits = mod(count, 8.0);\r\n    float t1[BYTE_COUNT];\r\n    biguintAssign(t1, b);\r\n    for (int i = 0; i < BYTE_COUNT - 1; i++)\r\n        t1[i] = biguintOrByte(biguintRshiftByte(t1[i], bits),\r\n                              biguintLshiftByte(t1[i+1], 8.0-bits));\r\n    t1[BYTE_COUNT-1] = biguintRshiftByte(t1[BYTE_COUNT-1], bits);\r\n    biguintAssignIfTrue(b, t1, float(bits != 0.0));\r\n}",biguintRshiftByOne:"#ifndef BYTE_COUNT\r\n#define BYTE_COUNT 16\r\n#endif\r\n\r\n#ifdef GL_ES\r\nprecision highp float;\r\nprecision highp int;\r\n#endif\r\n\r\nfloat biguintLshiftByte(float, float);\r\nfloat biguintRshiftByte(float, float);\r\nfloat biguintOrByte(float, float);\r\n\r\nvoid biguintRshiftByOne(inout float a[BYTE_COUNT]) {\r\n    for (int i = 0; i < BYTE_COUNT - 1; i++)\r\n        a[i] = biguintOrByte(biguintRshiftByte(a[i], 1.0),\r\n                             biguintLshiftByte(a[i+1], 8.0-1.0));\r\n    a[BYTE_COUNT-1] = biguintRshiftByte(a[BYTE_COUNT-1], 1.0);\r\n}",biguintRshiftByte:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\nfloat biguintRshiftByte(float i, float m) {\n    return floor(i * float(m == 0.0)\n               + i * float(m == 1.0) / 2.0\n               + i * float(m == 2.0) / 4.0\n               + i * float(m == 3.0) / 8.0\n               + i * float(m == 4.0) / 16.0\n               + i * float(m == 5.0) / 32.0\n               + i * float(m == 6.0) / 64.0\n               + i * float(m == 7.0) / 128.0);\n}",biguintRshiftWord:"#ifndef BYTE_COUNT\n#define BYTE_COUNT 16\n#endif\n\n#ifdef GL_ES\nprecision highp float;\nprecision highp int;\n#endif\n\n#ifndef FLOAT_LT\n#define FLOAT_LT\nfloat lt(float f1, float f2) {\n  return max(sign(f2 - f1), 0.0);\n}\n#endif\n\nvoid biguintRshiftWord(inout float a[BYTE_COUNT], float count) {\n    for (int i = 0; i < BYTE_COUNT; i++) \n        a[i] = a[int(min(float(i)+count, float(BYTE_COUNT) - 1.0))]\n             * lt(float(i)+count, float(BYTE_COUNT));\n}",biguintSqrt:"#ifndef BYTE_COUNT\r\n#define BYTE_COUNT 16\r\n#endif\r\n\r\n#ifdef GL_ES\r\nprecision highp float;\r\nprecision highp int;\r\n#endif\r\n\r\nvoid biguintRshift(float [BYTE_COUNT], inout float [BYTE_COUNT], float);\r\nvoid biguintAdd(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);\r\nvoid biguintAdd(float [BYTE_COUNT], float, inout float [BYTE_COUNT]);\r\nfloat biguintLessThan(float [BYTE_COUNT], float [BYTE_COUNT]);\r\nfloat biguintLessThanOrEqual(float [BYTE_COUNT], float [BYTE_COUNT]);\r\nfloat biguintGreaterThan(float [BYTE_COUNT], float [BYTE_COUNT]);\r\nfloat biguintGreaterThanOrEqual(float [BYTE_COUNT], float [BYTE_COUNT]);\r\nvoid biguintMul(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);\r\nvoid biguintSub(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);\r\nvoid biguintSub(float [BYTE_COUNT], float, inout float [BYTE_COUNT]);\r\nvoid biguintAssign(inout float [BYTE_COUNT], float [BYTE_COUNT]);\r\nvoid biguintAssignIfTrue(inout float [BYTE_COUNT], float [BYTE_COUNT], float);\r\nvoid biguintRshiftByOne(inout float [BYTE_COUNT]);\r\n\r\nvoid biguintSqrt(inout float a[BYTE_COUNT]) {\r\n    float low[BYTE_COUNT], high[BYTE_COUNT], mid[BYTE_COUNT], t1[BYTE_COUNT];\r\n    biguintAssign(high, a);\r\n    biguintRshift(high, mid, 1.0);\r\n    biguintAdd(mid, 1.0, mid);\r\n    for (int i = 0; i < BYTE_COUNT * 8; i++) {\r\n        if (biguintLessThanOrEqual(high, low) == 1.0) break;\r\n        biguintMul(mid, mid, t1);\r\n        float isGreaterThan = biguintGreaterThan(t1, a);\r\n        biguintAssign(t1, mid);\r\n        biguintSub(t1, 1.0, t1);\r\n        biguintAssignIfTrue(high, t1, isGreaterThan);\r\n\t\tbiguintAssignIfTrue(low, mid, 1.0 - isGreaterThan);\r\n\t\tbiguintSub(high, low, mid);\r\n        biguintRshiftByOne(mid);\r\n        biguintAdd(low, mid, mid);\r\n        biguintAdd(mid, 1.0, mid);\r\n    }\r\n    biguintAssign(a, low);\r\n}\r\n\r\nvoid biguintSqrt(float a[BYTE_COUNT], inout float b[BYTE_COUNT]) {\r\n    biguintAssign(b, a);\r\n    biguintSqrt(b);\r\n}",biguintSub:"#ifndef BYTE_COUNT\r\n#define BYTE_COUNT 16\r\n#endif\r\n\r\n#ifdef GL_ES\r\nprecision highp float;\r\nprecision highp int;\r\n#endif\r\n\r\n#ifndef FLOAT_LTZ\r\n#define FLOAT_LTZ\r\nfloat ltz(float f) {\r\n  return abs(min(sign(f), 0.0));\r\n}\r\n#endif\r\n\r\nvoid biguintAssign(inout float [BYTE_COUNT], float);\r\n\r\nvoid biguintSub(float a[BYTE_COUNT], float b[BYTE_COUNT], inout float c[BYTE_COUNT]) {\r\n    float borrow, tmp;\r\n    for (int i = 0; i < BYTE_COUNT; i++) {\r\n        tmp = a[i] - b[i] - borrow;\r\n        borrow = ltz(tmp);\r\n        c[i] = mod(tmp, 256.0); \r\n    }\r\n}\r\n\r\nvoid biguintSub(float a[BYTE_COUNT], float bf, inout float c[BYTE_COUNT]) {\r\n    float b[BYTE_COUNT];\r\n    biguintAssign(b, bf);\r\n    biguintSub(a, b, c);\r\n}",biguintXor:"#ifndef BYTE_COUNT\r\n#define BYTE_COUNT 16\r\n#endif\r\n\r\n#ifdef GL_ES\r\nprecision highp float;\r\nprecision highp int;\r\n#endif\r\n\r\n#ifndef FLOAT_NE\r\n#define FLOAT_NE\r\nfloat ne(float f1, float f2) {\r\n  return 1.0 - float(f1 == f2);\r\n}\r\n#endif\r\n\r\n#ifndef FLOAT_GTE\r\n#define FLOAT_GTE\r\nfloat gte(float f1, float f2) {\r\n  return 1.0 - max(sign(f2 - f1), 0.0);\r\n}\r\n#endif\r\n\r\nvoid biguintXor(float a[BYTE_COUNT], float b[BYTE_COUNT], inout float c[BYTE_COUNT]) {\r\n    for (int i = 0; i < BYTE_COUNT; i++) {\r\n        float o = ne(gte(a[i], 128.0), gte(b[i], 128.0)) * 128.0;\r\n        a[i] -= gte(a[i], 128.0) * 128.0;\r\n        b[i] -= gte(b[i], 128.0) * 128.0;\r\n        o += ne(gte(a[i], 64.0), gte(b[i], 64.0)) * 64.0;\r\n        a[i] -= gte(a[i], 64.0) * 64.0;\r\n        b[i] -= gte(b[i], 64.0) * 64.0;\r\n        o += ne(gte(a[i], 32.0), gte(b[i], 32.0)) * 32.0;\r\n        a[i] -= gte(a[i], 32.0) * 32.0;\r\n        b[i] -= gte(b[i], 32.0) * 32.0;\r\n        o += ne(gte(a[i], 16.0), gte(b[i], 16.0)) * 16.0;\r\n        a[i] -= gte(a[i], 16.0) * 16.0;\r\n        b[i] -= gte(b[i], 16.0) * 16.0;\r\n        o += ne(gte(a[i], 8.0), gte(b[i], 8.0)) * 8.0;\r\n        a[i] -= gte(a[i], 8.0) * 8.0;\r\n        b[i] -= gte(b[i], 8.0) * 8.0;\r\n        o += ne(gte(a[i], 4.0), gte(b[i], 4.0)) * 4.0;\r\n        a[i] -= gte(a[i], 4.0) * 4.0;\r\n        b[i] -= gte(b[i], 4.0) * 4.0;\r\n        o += ne(gte(a[i], 2.0), gte(b[i], 2.0)) * 2.0;\r\n        a[i] -= gte(a[i], 2.0) * 2.0;\r\n        b[i] -= gte(b[i], 2.0) * 2.0;\r\n        c[i] = o + ne(gte(a[i], 1.0), gte(b[i], 1.0));\r\n    }\r\n}"};t.functionStrings=r,Object.keys(r).forEach(n=>{const t=r;t[n]=t[n].replace(/\r+/gm,"").replace(/\t/g,"    ").replace(/\n{3,}/g,"\n\n")});const a=Object.assign({},r);t.untouchedFunctionStrings=a;const f={biguintAdd:{prepend:["#ifndef BIG_UINT_ADD","#define BIG_UINT_ADD"].join("\n"),declarations:["void biguintAdd(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);","void biguintAdd(float [BYTE_COUNT], float, inout float [BYTE_COUNT]);"],append:"#endif"},biguintAnd:{prepend:["#ifndef BIG_UINT_AND","#define BIG_UINT_AND"].join("\n"),declarations:["void biguintAnd(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);"],append:"#endif"},biguintAssign:{prepend:["#ifndef BIG_UINT_ASSIGN","#define BIG_UINT_ASSIGN"].join("\n"),declarations:["void biguintAssign(inout float [BYTE_COUNT], float [BYTE_COUNT]);","void biguintAssign(inout float [BYTE_COUNT], float);"],append:"#endif"},biguintAssignIfTrue:{prepend:["#ifndef BIG_UINT_ASSIGN_IF_TRUE","#define BIG_UINT_ASSIGN_IF_TRUE"].join("\n"),declarations:["void biguintAssignIfTrue(inout float [BYTE_COUNT], float [BYTE_COUNT], float);","void biguintAssignIfTrue(inout float [BYTE_COUNT], float [BYTE_COUNT], bool);","void biguintAssignIfTrue(inout float [BYTE_COUNT], float, float);","void biguintAssignIfTrue(inout float [BYTE_COUNT], float, bool);"],append:"#endif"},biguintDiv:{prepend:["#ifndef BIG_UINT_DIV","#define BIG_UINT_DIV"].join("\n"),declarations:["void biguintDiv(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);","void biguintDiv(float [BYTE_COUNT], float, inout float [BYTE_COUNT]);"],append:"#endif"},biguintEquals:{prepend:["#ifndef BIG_UINT_EQUALS","#define BIG_UINT_EQUALS"].join("\n"),declarations:["float biguintEquals(float [BYTE_COUNT], float [BYTE_COUNT]);","float biguintEquals(float [BYTE_COUNT], float);"],append:"#endif"},biguintGreaterThan:{prepend:["#ifndef BIG_UINT_GREATER_THAN","#define BIG_UINT_GREATER_THAN"].join("\n"),declarations:["float biguintGreaterThan(float [BYTE_COUNT], float [BYTE_COUNT]);","float biguintGreaterThan(float [BYTE_COUNT], float);"],append:"#endif"},biguintGreaterThanOrEqual:{prepend:["#ifndef BIG_UINT_GREATER_THAN_OR_EQUAL","#define BIG_UINT_GREATER_THAN_OR_EQUAL"].join("\n"),declarations:["float biguintGreaterThanOrEqual(float [BYTE_COUNT], float [BYTE_COUNT]);","float biguintGreaterThanOrEqual(float [BYTE_COUNT], float);"],append:"#endif"},biguintLessThan:{prepend:["#ifndef BIG_UINT_LESS_THAN","#define BIG_UINT_LESS_THAN"].join("\n"),declarations:["float biguintLessThan(float [BYTE_COUNT], float [BYTE_COUNT]);","float biguintLessThan(float [BYTE_COUNT], float);"],append:"#endif"},biguintLessThanOrEqual:{prepend:["#ifndef BIG_UINT_LESS_THAN_OR_EQUAL","#define BIG_UINT_LESS_THAN_OR_EQUAL"].join("\n"),declarations:["float biguintLessThanOrEqual(float [BYTE_COUNT], float [BYTE_COUNT]);","float biguintLessThanOrEqual(float [BYTE_COUNT], float);"],append:"#endif"},biguintLshift:{prepend:["#ifndef BIG_UINT_LSHIFT","#define BIG_UINT_LSHIFT"].join("\n"),declarations:["void biguintLshift(float [BYTE_COUNT], inout float [BYTE_COUNT], float);"],append:"#endif"},biguintLshiftByOne:{prepend:["#ifndef BIG_UINT_LSHIFT_BY_ONE","#define BIG_UINT_LSHIFT_BY_ONE"].join("\n"),declarations:["void biguintLshiftByOne(inout float [BYTE_COUNT]);"],append:"#endif"},biguintLshiftByte:{prepend:["#ifndef BIG_UINT_LSHIFT_BYTE","#define BIG_UINT_LSHIFT_BYTE"].join("\n"),declarations:["float biguintLshiftByte(float, float);"],append:"#endif"},biguintLshiftWord:{prepend:["#ifndef BIG_UINT_LSHIFT_WORD","#define BIG_UINT_LSHIFT_WORD"].join("\n"),declarations:["void biguintLshiftWord(inout float [BYTE_COUNT], float);"],append:"#endif"},biguintMod:{prepend:["#ifndef BIG_UINT_MOD","#define BIG_UINT_MOD"].join("\n"),declarations:["void biguintMod(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);","void biguintMod(float [BYTE_COUNT], float, inout float [BYTE_COUNT]);"],append:"#endif"},biguintMul:{prepend:["#ifndef BIG_UINT_MUL","#define BIG_UINT_MUL"].join("\n"),declarations:["void biguintMul(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);","void biguintMul(float [BYTE_COUNT], float, inout float [BYTE_COUNT]);"],append:"#endif"},biguintOr:{prepend:["#ifndef BIG_UINT_OR","#define BIG_UINT_OR"].join("\n"),declarations:["void biguintOr(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);"],append:"#endif"},biguintOrByte:{prepend:["#ifndef BIG_UINT_OR_BYTE","#define BIG_UINT_OR_BYTE"].join("\n"),declarations:["float biguintOrByte(float, float);"],append:"#endif"},biguintPow:{prepend:["#ifndef BIG_UINT_POW","#define BIG_UINT_POW"].join("\n"),declarations:["void biguintPow(float [BYTE_COUNT], float, inout float [BYTE_COUNT]);"],append:"#endif"},biguintRshift:{prepend:["#ifndef BIG_UINT_RSHIFT","#define BIG_UINT_RSHIFT"].join("\n"),declarations:["void biguintRshift(float [BYTE_COUNT], inout float [BYTE_COUNT], float);"],append:"#endif"},biguintRshiftByOne:{prepend:["#ifndef BIG_UINT_RSHIFT_BY_ONE","#define BIG_UINT_RSHIFT_BY_ONE"].join("\n"),declarations:["void biguintRshiftByOne(inout float [BYTE_COUNT]);"],append:"#endif"},biguintRshiftByte:{prepend:["#ifndef BIG_UINT_RSHIFT_BYTE","#define BIG_UINT_RSHIFT_BYTE"].join("\n"),declarations:["float biguintRshiftByte(float, float);"],append:"#endif"},biguintRshiftWord:{prepend:["#ifndef BIG_UINT_RSHIFT_WORD","#define BIG_UINT_RSHIFT_WORD"].join("\n"),declarations:["void biguintRshiftWord(inout float [BYTE_COUNT], float);"],append:"#endif"},biguintSqrt:{prepend:["#ifndef BIG_UINT_SQRT","#define BIG_UINT_SQRT"].join("\n"),declarations:["void biguintSqrt(float [BYTE_COUNT], inout float [BYTE_COUNT]);"],append:"#endif"},biguintSub:{prepend:["#ifndef BIG_UINT_SUB","#define BIG_UINT_SUB"].join("\n"),declarations:["void biguintSub(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);","void biguintSub(float [BYTE_COUNT], float, inout float [BYTE_COUNT]);"],append:"#endif"},biguintXor:{prepend:["#ifndef BIG_UINT_XOR","#define BIG_UINT_XOR"].join("\n"),declarations:["void biguintXor(float [BYTE_COUNT], float [BYTE_COUNT], inout float [BYTE_COUNT]);"],append:"#endif"}};t.declarations=f;const T=[["#ifndef BYTE_COUNT","#define BYTE_COUNT 16","#endif","","#ifdef GL_ES","precision highp float;","precision highp int;","#endif"].join("\n")];Object.assign(r,(0,o.renderDefinitions)(r,f,T))},function(n,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.unpackBooleans=function(n){var t=new Array(8);n=Math.min(Math.max(0,Math.round(n)),255);for(var i=0;i<8;i++){var e=Math.pow(2,7-i);n>=e?(t[i]=!0,n-=e):t[i]=!1}return t},t.packBooleans=function(n){for(var t=0,i=0;i<8;i++)n.length>i&&n[i]&&(t+=Math.pow(2,7-i));return t}},function(n,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.unpackInt16=function(n,t){return n=Math.min(Math.max(0,Math.floor(n)),255),t=Math.min(Math.max(0,Math.floor(t)),255),256*n+t-32767},t.packInt16=function(n){var t=new Array(2);return n=Math.min(Math.max(-32767,Math.round(n)),32768)+32767,t[0]=Math.floor(n/256),t[1]=n-256*t[0],t},t.MIN_INT16=t.MAX_INT16=void 0;t.MAX_INT16=32768;t.MIN_INT16=-32767},function(n,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.unpackUint16=function(n,t){return n=Math.min(Math.max(0,Math.floor(n)),255),t=Math.min(Math.max(0,Math.floor(t)),255),256*n+t},t.packUint16=function(n){var t=new Array(2);return n=Math.min(Math.max(0,Math.round(n)),65535),t[0]=Math.floor(n/256),t[1]=n-256*t[0],t},t.MIN_UINT16=t.MAX_UINT16=void 0;t.MAX_UINT16=65535;t.MIN_UINT16=0}]);